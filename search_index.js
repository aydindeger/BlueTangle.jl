var documenterSearchIndex = {"docs":
[{"location":"functions/#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Detailed explanations or additional notes about all functions.","category":"page"},{"location":"functions/#Measurement-functions","page":"Functions","title":"Measurement functions","text":"","category":"section"},{"location":"functions/#BlueTangle.sample","page":"Functions","title":"BlueTangle.sample","text":"sample(state::AbstractVectorS, shots::Int) -> Vector\n\nSample outcomes from a quantum state vector based on the probability distribution.\n\nstate: A sparse quantum state vector.\nshots: Number of samples to be taken.\n\nReturns a vector of sampled outcomes.\n\n\n\n\n\n","category":"function"},{"location":"functions/#BlueTangle.get_probs_from_sample","page":"Functions","title":"BlueTangle.get_probs_from_sample","text":"get_probs_from_sample(sample::Vector, N::Int) -> (Vector, Vector)\n\nConvert a sample of outcomes into probabilities.\n\nsample: A vector of sampled outcomes.\nN: Number of qubits.\n\nReturns a tuple of vectors: the first vector contains outcomes, and the second vector contains corresponding probabilities.\n\n\n\n\n\n","category":"function"},{"location":"functions/#BlueTangle.expect","page":"Functions","title":"BlueTangle.expect","text":"Alias:\n\nexpect(m::Measurement, qubit::Int) -> Float64\nexpect(m::Measurement) -> Vector\n\nCalculate the expectation value from a measurement.\n\nm: A Measurement object.\nqubit: (Optional) Specific qubit for which to calculate the expectation value.\n\nReturns the expectation value(s).\n\n\n\n\n\nAlias for density matrix:\n\nexpect(state::AbstractVectorS, op::QuantumOps) -> Float64\nexpect(state::AbstractVectorS, op_str::String, qubit::Int) -> Float64\nexpect(state::AbstractVectorS, matrix::sa.SparseMatrixCSC) -> Float64\nexpect(state::AbstractVectorS, op_str::String) -> Vector{Float64}\n\nAlias for state vector:\n\nexpect(rho::sa.SparseMatrixCSC, op::QuantumOps) -> Float64\nexpect(rho::sa.SparseMatrixCSC, op_str::String, qubit::Int) -> Float64\nexpect(rho::sa.SparseMatrixCSC, matrix::sa.SparseMatrixCSC) -> Float64\nexpect(rho::sa.SparseMatrixCSC, op_str::String) -> Vector{Float64}\n\nCalculate the expectation value for quantum states or density matrices given an operator. This function has several forms depending on the input parameters:\n\nexpect(state::AbstractVectorS, op::QuantumOps): Computes the expectation value for a quantum state vector with a given operator.\nexpect(rho::sa.SparseMatrixCSC, op::QuantumOps): Computes the expectation value for a density matrix with a given operator.\nexpect(state::AbstractVectorS, op_str::String, qubit::Int): Computes the expectation value for a specific qubit in a quantum state vector with an operator specified as a string.\nexpect(rho::sa.SparseMatrixCSC, op_str::String, qubit::Int): Computes the expectation value for a specific qubit in a density matrix with an operator specified as a string.\nexpect(state::AbstractVectorS, op_str::String): Computes the expectation values for all qubits in a quantum state vector given an operator as a string.\nexpect(rho::sa.SparseMatrixCSC, op_str::String): Computes the expectation values for all qubits in a density matrix given an operator as a string.\nexpect(state::AbstractVectorS, matrix::sa.SparseMatrixCSC): Computes the expectation value using a sparse matrix representation of an operator for a state vector.\nexpect(rho::sa.SparseMatrixCSC, matrix::sa.SparseMatrixCSC): Computes the expectation value using a sparse matrix representation of an operator for a density matrix.\n\nArguments\n\nstate::AbstractVectorS: The quantum state vector.\nrho::sa.SparseMatrixCSC: The density matrix.\nop::QuantumOps: The quantum operator.\nop_str::String: The string representation of the operator.\nqubit::Int: The specific qubit index.\nmatrix::sa.SparseMatrixCSC: The sparse matrix representation of the operator.\n\nReturns\n\nThe expectation value as a Float64 or a vector of Float64 for multiple qubits.\n\n\n\n\n\n","category":"function"},{"location":"functions/#BlueTangle.correlation","page":"Functions","title":"BlueTangle.correlation","text":"correlation(m::Measurement, qubits::Vector) -> Any\n\nCalculate correlation from a measurement on specified qubits.\n\nm: A Measurement object.\nqubits: Vector of qubits for measuring correlations, e.g. eg: qubits=[1,3] measure <Z1Z3>\n\nReturns the calculated correlation.\n\n\n\n\n\nAlias:\n\ncorrelation(state::AbstractVectorS, list_of_operators::String, qubits_applied::Vector) -> Float64\ncorrelation(rho::sa.SparseMatrixCSC, list_of_operators::String, qubits_applied::Vector) -> Float64\n\nCalculate the correlation for a given set of operators applied to specific qubits in either a quantum state vector or a density matrix. This function has two primary forms:\n\ncorrelation(state::AbstractVectorS, list_of_operators::String, qubits_applied::Vector): Computes the correlation for a quantum state vector (state) with a specified list of operators and qubits.\ncorrelation(rho::sa.SparseMatrixCSC, list_of_operators::String, qubits_applied::Vector): Computes the correlation for a density matrix (rho) with a specified list of operators and qubits.\n\nThe corr_from_rho function is an alias to get_corr for density matrices.\n\nArguments\n\nstate::AbstractVectorS: The quantum state vector.\nrho::sa.SparseMatrixCSC: The density matrix.\nlist_of_operators::String: A string representing a list of operators, e.g., \"Z,Z\".\nqubits_applied::Vector: A vector of qubit indices on which the operators are applied.\n\nReturns\n\nFloat64: The computed correlation value.\n\nExamples\n\n# For a state vector\nstate = sa.SparseVector([...]) # define your state vector\ncorrelation = correlation(state, \"Z,Z\", [2, 4])\n\n# For a density matrix\nrho = sa.SparseMatrixCSC([...]) # define your density matrix\ncorrelation = correlation(rho, \"Z,Z\", [2, 4])\n\n\n\n\n\n","category":"function"},{"location":"functions/#Circuit-functions","page":"Functions","title":"Circuit functions","text":"","category":"section"},{"location":"functions/#BlueTangle.compile","page":"Functions","title":"BlueTangle.compile","text":"compile(ops::Vector{<: QuantumOps}, options::Options=Options()) -> Circuit\n\nCompile a set of quantum operations into a circuit.\n\nops: A vector of QuantumOps objects.\noptions: Optional compilation options.\n\nReturns a compiled Circuit object.\n\n\n\n\n\n","category":"function"},{"location":"functions/#BlueTangle.measure","page":"Functions","title":"BlueTangle.measure","text":"measure(state::AbstractVectorS,number_of_experiment::Int)\n\nthis creates a measurement object from state vector.\n\n\n\n\n\n","category":"function"},{"location":"functions/#BlueTangle.measure_ZNE","page":"Functions","title":"BlueTangle.measure_ZNE","text":"measure_ZNE(circuit::Circuit, number_of_experiment::Int) -> Measurement\n\nMeasure a quantum circuit multiple times.\n\ncircuit: A Circuit object.\nnumber_of_experiment: Number of times to execute the circuit.\n\nReturns a Measurement object with the results.\n\n\n\n\n\n","category":"function"},{"location":"functions/#BlueTangle.to_state","page":"Functions","title":"BlueTangle.to_state","text":"to_state(circuit::Circuit; init_state::AbstractVectorS=sa.sparse([])) -> sa.SparseVector\n\nConvert a quantum circuit to a state vector.\n\ncircuit: A Circuit object.\ninit_state: (Optional) Initial state vector.\n\nReturns a state vector representing the circuit.\n\n\n\n\n\nto_state(MPS::it.MPS,M::Vector)\n\nConvert MPS to state vector\n\n\n\n\n\n","category":"function"},{"location":"functions/#BlueTangle.to_rho","page":"Functions","title":"BlueTangle.to_rho","text":"to_rho(circuit::Circuit) -> sa.SparseMatrixCSC\n\nConvert a quantum circuit to a density matrix (rho).\n\ncircuit: A Circuit object.\n\nReturns a density matrix representing the circuit.\n\n\n\n\n\n","category":"function"},{"location":"functions/#BlueTangle.to_MPS","page":"Functions","title":"BlueTangle.to_MPS","text":"to_MPS(vec::AbstractVector, sites::AbstractVector; kwargs...)\n\nConvert state vector to MPS\n\n\n\n\n\n","category":"function"},{"location":"functions/#Quantum-Toolkit","page":"Functions","title":"Quantum Toolkit","text":"","category":"section"},{"location":"functions/#BlueTangle.entanglement_entropy","page":"Functions","title":"BlueTangle.entanglement_entropy","text":"entanglement_entropy(psi::AbstractVectorS) -> Float64\n\nCalculates the entanglement entropy of a quantum state.\n\npsi: The quantum state vector (sa.SparseVector) for which to calculate the entropy.\n\nReturns the calculated entanglement entropy.\n\n\n\n\n\nentanglement_entropy(rho::sa.SparseMatrixCSC) -> Float64\n\nCalculates the entanglement entropy of a density matrix.\n\nrho: The density matrix (sa.SparseMatrixCSC) for which to calculate the entropy.\n\nReturns the calculated entanglement entropy.\n\n\n\n\n\n","category":"function"},{"location":"functions/#BlueTangle.shadow","page":"Functions","title":"BlueTangle.shadow","text":"shadow(circuit::Circuit, number_of_experiment::Int) -> sa.SparseMatrixCSC\n\nConstruct a density matrix (rho) from classical shadow representation.\n\ncircuit: A Circuit object.\nnumber_of_experiment: Number of experiments to run.\n\nReturns a sparse density matrix representing the classical shadow.\n\n\n\n\n\n","category":"function"},{"location":"functions/#BlueTangle.mag_moments","page":"Functions","title":"BlueTangle.mag_moments","text":"mag_moments(rho::sa.SparseMatrixCSC, op_str::String, moment_order::Int) -> Float64\n\nCalculates the magnetization moments from a given density matrix.\n\nrho: The density matrix (sa.SparseMatrixCSC) of the quantum system.\nop_str: String representation of the operator used for calculating the magnetization.\nmoment_order: The order of the magnetization moment to compute.\n\nReturns the computed magnetization moment of the specified order.\n\n\n\n\n\ncalculates average magnetization moments from sample\n\n\n\n\n\n","category":"function"},{"location":"functions/#Other","page":"Functions","title":"Other","text":"","category":"section"},{"location":"functions/#BlueTangle.get_N","page":"Functions","title":"BlueTangle.get_N","text":"get_N(state::AbstractVectorS) -> Int\nget_N(rho::AbstractMatrixS) -> Int\n\n\n\n\n\nqubit number from a set of operations\n\n\n\n\n\n","category":"function"},{"location":"functions/#BlueTangle.fock_basis_create","page":"Functions","title":"BlueTangle.fock_basis_create","text":"fock_basis_create(N::Int)\n\n\n\n\n\n","category":"function"},{"location":"functions/#BlueTangle.hilbert","page":"Functions","title":"BlueTangle.hilbert","text":"hilbert(N::Int, mat::AbstractMatrix, qubit::Int, target_qubit::Int)\n\nConstructs a sparse matrix representing the action of a quantum gate in a Hilbert space associated with a quantum system of N qubits\n\nThe gate mat is applied to the qubit andtarget_qubit. If qubit is greater than target_qubit, a controlled  swap is performed before applying mat.\n\nArguments\n\nN::Int: The number of qubits in the system.\nmat::AbstractMatrix: The quantum gate to be applied.\nqubit::Int: The qubit to which the gate is applied.\ntarget_qubit::Int: The target qubit to which the gate is applied.\n\nReturns\n\nSparseMatrix: The resulting sparse matrix representation of the gate operation.\n\n\n\n\n\nhilbert(N::Int, mat::AbstractMatrix, qubit::Int)\n\nConstructs a sparse matrix representing the action of a quantum gate in a Hilbert space associated with a quantum system of N qubits.\n\nArguments\n\nN::Int: The number of qubits in the system.\nmat::AbstractMatrix: The quantum gate to be applied.\nqubit::Int: The qubit to which the gate is applied.\n\nReturns\n\nSparseMatrix: The resulting sparse matrix representation of the gate operation.\n\n\n\n\n\n","category":"function"},{"location":"functions/#BlueTangle.expand_multi_op","page":"Functions","title":"BlueTangle.expand_multi_op","text":"expand_multi_op(list_of_operators::String, qubits_applied::Vector, N::Int) -> Matrix\n\nExpand multiple quantum operators over a specified set of qubits.\n\nlist_of_operators: A string representing a list of operators.\nqubits_applied: A vector of qubits on which operators are applied.\nN: Total number of qubits.\n\nReturns a matrix representing the expanded operators.\n\n\n\n\n\n","category":"function"},{"location":"functions/#BlueTangle.string_to_matrix","page":"Functions","title":"BlueTangle.string_to_matrix","text":"string_to_matrix(list_of_operators::String) -> Matrix\n\nConvert a string of comma-separated operators into a matrix representation.\n\nlist_of_operators: A string representing a list of operators, e.g.: \"Z,Z,sa.IP(.2)\"\n\nReturns a matrix representation of the operators.\n\n\n\n\n\n","category":"function"},{"location":"functions/#BlueTangle.zero_state","page":"Functions","title":"BlueTangle.zero_state","text":"zero_state(N::Int) -> sa.SparseVector\n\nReturns a sparse vector representing the |000...> quantum state.\n\n\n\n\n\ncreate all zero state\n\n\n\n\n\n","category":"function"},{"location":"functions/#BlueTangle.one_state","page":"Functions","title":"BlueTangle.one_state","text":"create all one state\n\n\n\n\n\n","category":"function"},{"location":"functions/#BlueTangle.product_state","page":"Functions","title":"BlueTangle.product_state","text":"product_state(list_of_qubits::Vector) -> sa.SparseVector\n\nCreates a quantum state vector from a list of qubits.\n\nlist_of_qubits: A vector representing the state of each qubit.\n\nReturns a sparse vector representing the quantum state of the system.\n\n\n\n\n\ncreate given product state\n\n\n\n\n\n","category":"function"},{"location":"functions/#BlueTangle.neel_state01","page":"Functions","title":"BlueTangle.neel_state01","text":"create neel state 010101\n\n\n\n\n\n","category":"function"},{"location":"functions/#BlueTangle.neel_state10","page":"Functions","title":"BlueTangle.neel_state10","text":"create neel state 101010\n\n\n\n\n\n","category":"function"},{"location":"functions/#BlueTangle.apply","page":"Functions","title":"BlueTangle.apply","text":"apply(state::AbstractVectorS, op::QuantumOps)\n\nApply a quantum gate operation to a state vector in place.\n\nstate: A sparse quantum state vector to be modified.\nop: A QuantumOps object representing the gate operation.\n\nModifies the state vector directly.\n\n\n\n\n\napply(rho::sa.SparseMatrixCSC, op::QuantumOps)\n\nApply a quantum gate operation to a state vector in place.\n\nrho: A sparse quantum density matrix to be modified.\nop: A QuantumOps object representing the gate operation.\n\nModifies the state vector directly.\n\n\n\n\n\n","category":"function"},{"location":"functions/#BlueTangle.linear_fit","page":"Functions","title":"BlueTangle.linear_fit","text":"linear_fit(xdata::Vector, ydata::Vector)\n\nCompute the coefficients a and b for the linear fit of the given data.\n\nArguments\n\nxdata: Array of x values.\nydata: Array of corresponding y values.\n\nReturns\n\na: Intercept of the linear fit.\nb: Slope of the linear fit.\nse_a: Standard error of the intercept.\nse_b: Standard error of the slope.\n\nDescription\n\nThis function fits a simple linear model (y = a + b*x) to the provided data points. It checks if the lengths of xdata and ydata are the same and then calculates the coefficients for the linear fit. Additionally, it computes the standard errors for both the slope and the intercept.\n\nThe function uses the least squares method for the linear regression. The standard errors are calculated based on the residual sum of squares and the total sum of squares for the x values.\n\n\n\n\n\n","category":"function"},{"location":"functions/#BlueTangle.quadratic_fit","page":"Functions","title":"BlueTangle.quadratic_fit","text":"quadratic_fit(xdata::Vector{Float64}, ydata::Vector{Float64}) -> Vector{Float64}\n\nFit a quadratic function to the given data.\n\nArguments\n\nxdata::Vector{Float64}: A vector of x-coordinates.\nydata::Vector{Float64}: A vector of y-coordinates corresponding to xdata.\n\nReturns\n\nVector{Float64}: The coefficients [a, b, c] of the fitted quadratic function y = ax^2 + bx + c.\n\nDescription\n\nThis function performs a least squares quadratic fit to the input data.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Object-types","page":"Functions","title":"Object types","text":"","category":"section"},{"location":"functions/#BlueTangle.QuantumOps","page":"Functions","title":"BlueTangle.QuantumOps","text":"QuantumOps\n\nAbstract type representing quantum operations.\n\n\n\n\n\n","category":"type"},{"location":"functions/#BlueTangle.Op","page":"Functions","title":"BlueTangle.Op","text":"Op(q::Int, name::String, mat::AbstractMatrix, qubit::Int, target_qubit::Int, noise::QuantumChannel) <: QuantumOps\n\nRepresents a quantum operation.\n\nq: Number of qubits involved in the operation.\nname: Name of the operation.\nmat: Matrix representation of the quantum operation.\nqubit: index of the target qubit.\ntarget_qubit: index of the target qubit for two-qubit operations.\nnoise: Noise model associated with the operation.\n\nConstructs an Op object representing a quantum operation with optional noise.\n\n\n\n\n\n","category":"type"},{"location":"functions/#BlueTangle.ifOp","page":"Functions","title":"BlueTangle.ifOp","text":"ifOp(q::Int, name::String, mat::AbstractMatrix, qubit::Int, if01::Tuple{Matrix,Matrix}, noise::QuantumChannel) <: QuantumOps\n\nRepresents a conditional quantum operation used for mid-circuit born measurements. It is specifically designed for mid-circuit measurements in the X, Y, Z, or a random basis (R). Depending on the measurement outcomes (0 or 1), different gates specified in if01 can be applied.\n\nFields\n\nq: Integer representing the number of qubits involved in the operation.\nname: String indicating the name of the operation. Valid names are \"MX\", \"MY\", \"MZ\", or \"MR\", corresponding to operations in the X, Y, Z basis, or a random basis (R), respectively.\nmat: Matrix representing the quantum operation.\nqubit: Integer specifying the index of the target qubit.\nif01: Tuple of two matrices. The first matrix is applied if the measured state of the qubit is 0, and the second matrix is applied if the measured state is 1.\nnoise: Represents a 'born measurement quantum channel', indicating the noise model associated with the operation.\n\nUsage\n\nifOp is constructed to represent quantum operations that are conditional on the measurement outcome of a qubit. This operator is particularly useful in quantum circuits for implementing dynamic responses based on mid-circuit measurement results.\n\nExamples\n\n```julia\n\nExample of creating an ifOp for a conditional operation based on the X-basis measurement (MX)\n\nconditionalop = ifOp(\"MX\", qubit, (operationif0, operationif_1))\n\n\n\n\n\n","category":"type"},{"location":"functions/#BlueTangle.Measurement","page":"Functions","title":"BlueTangle.Measurement","text":"Measurement(bitstr::Union{Vector, UnitRange}, sample::Vector, expect::Vector, mag_moments::Vector, measurement_basis::String, number_of_experiment::Int, circuit_name::String, number_of_qubits::Int, density_matrix::sa.SparseMatrixCSC)\n\nRepresents the result of quantum measurements.\n\nbitstr: Basis of measurement represented as integers or a range.\nsample: Vector of probabilities.\nexpect: Expectation values of the measurement.\nmag_moments: Magnetic moments obtained from the measurement.\nmeasurement_basis: Measurement basis used.\nnumber_of_experiment: Number of experiments performed.\ncircuit_name: Name of the circuit used.\nnumber_of_qubits: Number of qubits involved.\ndensity_matrix: Density matrix obtained from the measurement.\n\nConstructs a Measurement object to store the results of quantum measurements.\n\n\n\n\n\n","category":"type"},{"location":"functions/#BlueTangle.QuantumChannel","page":"Functions","title":"BlueTangle.QuantumChannel","text":"QuantumChannel(q::Int, model::String, p::Float64)\n\nRepresents a quantum noise channel.\n\nq: Number of qubits affected by the noise channel.\nmodel: The noise model type as a string.\np: Probability parameter for the noise model.\nkraus: A vector of matrices representing Kraus operators for the channel.\n\nConstructs a QuantumChannel object for specified qubits, noise model, and probability.\n\n\n\n\n\n","category":"type"},{"location":"functions/#BlueTangle.NoiseModel","page":"Functions","title":"BlueTangle.NoiseModel","text":"Create a NoiseModel\n\n\n\n\n\n","category":"type"},{"location":"functions/#BlueTangle.AnsatzOptions","page":"Functions","title":"BlueTangle.AnsatzOptions","text":"AnsatzOptions(; N::Int, ops::Union{Vector{String},Vector{<:QuantumOps}}, noise=false, init::Union{sa.SparseVector,Circuit}=sa.sparse([]), model::String=\"lbfgs\", number_of_iterations::Int=1000, learning_rate::Float64=0.01, pars_initial::Vector=[], deep_circuit::Bool=false, history::Bool=true)\n\nConstructs an AnsatzOptions object that contains the configuration for a variational quantum circuit ansatz.\n\nArguments\n\nN::Int: The number of qubits in the ansatz.\nops::Union{Vector{String},Vector{<:QuantumOps}}: The quantum operations defining the ansatz, either as a vector of strings or a vector of QuantumOps.\nnoise=false: Specifies whether to include noise in the ansatz. Can be either a NoiseModel or a boolean value.\ninit::Union{sa.SparseVector,Circuit}=sa.sparse([]): The initial state of the ansatz, either as a sparse vector or a Circuit. Defaults to the zero state.\n\nOptimization Models\n\nGradient-Free Models (uses PRIMA.jl)\n\n\"cobyla\": Affine model, supports bounds, linear, and non-linear constraints.\n\"newuoa\": Quadratic model, no constraints.\n\"uobyqa\": Quadratic model, no constraints.\n\"bobyqa\": Quadratic model, supports bounds.\n\"lincoa\": Quadratic model, supports bounds and linear constraints.\n\"prima\": Automatically picks the best PRIMA model.\n\nGradient-Based Models (uses ForwardDiff.jl, Optimisers.jl, OptimKit.jl]\n\n\"lbfgs\": Uses LBFGS optimizer (gradient-based).\n\"adam\": Uses Adam optimizer (gradient-based).\n\"descent\": Uses gradient descent optimizer.\n\"radam\": Uses RAdam optimizer.\n\"momentum\": Uses Momentum optimizer.\n\"nesterov\": Uses Nesterov optimizer.\nnumber_of_iterations::Int=1000: The number of iterations for the optimization.\nlearning_rate::Float64=0.01: The learning rate for the optimization.\npars_initial::Vector=[]: The initial parameters for the ansatz. If not provided, random parameters are generated.\ndeep_circuit::Bool=false: Specifies whether to use a deep circuit ansatz.\nhistory::Bool=true: Specifies whether to record the optimization history.\n\nReturns\n\nAn AnsatzOptions object containing the configuration for the variational quantum circuit ansatz.\n\n\n\n\n\n","category":"type"},{"location":"functions/#BlueTangle.Circuit","page":"Functions","title":"BlueTangle.Circuit","text":"Circuit\n\nRepresents a quantum circuit.\n\nstats: NamedTuple containing statistics about the circuit.\noptions: Options object with circuit configurations.\nops: Vector of QuantumOps representing the operations in the circuit.\n\nConstructs a Circuit object representing a quantum circuit.\n\n\n\n\n\n","category":"type"},{"location":"functions/#BlueTangle.Options","page":"Functions","title":"BlueTangle.Options","text":"Options(circuit_name::String, measurement_basis::String, final_measurement_noise::QuantumChannel, Noise1::QuantumChannel, Noise2::QuantumChannel, twirl::Bool, noisy_swap::Bool, density_matrix::Bool)\n\nRepresents configuration options for a quantum circuit.\n\ncircuit_name: Name of the circuit.\nmeasurement_basis: Measurement basis used in the circuit.\nfinal_measurement_noise: Noise model for final measurement error.\nnoise: Noise model for single-qubit and two-qubit operations.\ntwirl: Boolean flag for twirling operations.\nnoisy_swap: Boolean flag for swap errors.\ndensity_matrix: Boolean flag to indicate if density matrix should be calculated.\n\nConstructs an Options object with specified settings for a quantum circuit.\n\n\n\n\n\n","category":"type"},{"location":"functions/#BlueTangle.Layout","page":"Functions","title":"BlueTangle.Layout","text":"Create Layout\n\n\n\n\n\n","category":"type"},{"location":"functions/#Gates","page":"Functions","title":"Gates","text":"","category":"section"},{"location":"functions/#BlueTangle.gate","page":"Functions","title":"BlueTangle.gate","text":"gate\n\nA constant that holds common quantum gates and projectors.\n\nThis includes:\n\nIdentity (I)\nPauli gates (X, Y, Z)\nHadamard (H)\nPhase gates (S, T)\nSpecial gates like sqrt(X) (equal to RX(pi/2)exp(1impi/4))\nProjectors (P0 for |0><0|, P1 for |1><1|)\nControlled gates such as CX (CNOT), CNOT (an alias for CX), and CZ\nThe SWAP, ISWAP, FSWAP gate\nThe ECR, SYC gate\n\nEach single-qubit gate is represented as a 2x2 matrix, while multi-qubit gates like CNOT, ECR, SYC, CZ, and SWAP, ISWAP, FSWAP are represented as 4x4 matrices.\n\n\n\n\n\n","category":"constant"},{"location":"functions/#BlueTangle.random_ops","page":"Functions","title":"BlueTangle.random_ops","text":"random_ops_2(N::Int, len::Int; measure_prob::Float64=0.0, measure_basis::Vector{String}=[\"MX\", \"MY\", \"MZ\"]) -> Vector{QuantumOps}\n\nCreate a sequence of random quantum gate operations, with optional mid-circuit measurements.\n\nArguments\n\nN::Int: The number of qubits in the system.\nlen::Int: The length of the sequence of operations to generate.\n\nKeyword Arguments\n\nmeasure_prob::Float64: The probability of adding a measurement operation after each gate.\nmeasure_basis::Vector{String}: The basis in which measurements are performed.\n\nReturns\n\nVector{QuantumOps}: A vector of randomly chosen quantum operations (QuantumOps), each representing a gate or a measurement operation.\n\nDescription\n\nThis function creates a vector of quantum operations, where each operation is either a randomly chosen gate from the set {\"X\", \"Y\", \"Z\", \"H\", \"S\", \"CX\",\"CZ\",\"CP\",\"GIVENS\",\"FSIM\",\"SWAP\",\"ISWAP\",\"FSWAP\",\"SYC\",\"ECR\"} or a measurement operation, based on measure_prob. \n\nExample\n\nops = random_ops(5, 10; measure_prob=0.2, measure_basis=[\"MX\",\"MZ\"])\n\nThis example generates a sequence of 10 random gates and measurements (with a 20% chance of a measurement after each gate) for a 5-qubit system.\n\n\n\n\n\n","category":"function"},{"location":"functions/#BlueTangle.random_clifford","page":"Functions","title":"BlueTangle.random_clifford","text":"random_clifford(N::Int, len::Int; measure_prob::Float64=0.0, measure_basis::Vector{String}=[\"MX\",\"MY\",\"MZ\"]) -> Vector{QuantumOps}\n\nGenerate a random sequence of Clifford gates, with optional mid-circuit measurements.\n\nArguments\n\nN::Int: The number of qubits in the system.\nlen::Int: The length of the sequence of operations to generate.\n\nKeyword Arguments\n\nmeasure_prob::Float64: The probability of adding a measurement operation after each gate.\nmeasure_basis::Vector{String}: The basis in which measurements are performed.\n\nReturns\n\nVector{QuantumOps}: A vector of randomly chosen quantum operations (QuantumOps), each representing a Clifford gate or a measurement operation.\n\nDescription\n\nThis function creates a vector of quantum operations, where each operation is either a randomly chosen Clifford gate from the set {\"X\", \"Y\", \"Z\", \"H\", \"S\", \"CNOT\", \"SWAP\", \"CZ\"} or a measurement operation, based on measure_prob. For two-qubit gates (\"CNOT\", \"SWAP\", \"CZ\"), adjacent qubits (qubit r and qubit r+1) are selected. For single-qubit gates and measurements, a random qubit r is chosen.\n\nExample\n\nops = random_clifford(5, 10; measure_prob=0.2, measure_basis=[\"MX\",\"MZ\"])\n\nThis example generates a sequence of 10 random Clifford gates and measurements (with a 20% chance of a measurement after each gate) for a 5-qubit system.\n\n\n\n\n\n","category":"function"},{"location":"functions/#BlueTangle.get_stats","page":"Functions","title":"BlueTangle.get_stats","text":"get statistics about the operations\n\n\n\n\n\n","category":"function"},{"location":"functions/#BlueTangle.get_layers","page":"Functions","title":"BlueTangle.get_layers","text":"get_layers for a given set of ops\n\n\n\n\n\n","category":"function"},{"location":"functions/#Noise","page":"Functions","title":"Noise","text":"","category":"section"},{"location":"functions/#BlueTangle.is_valid_quantum_channel","page":"Functions","title":"BlueTangle.is_valid_quantum_channel","text":"is_valid_quantum_channel(kraus::Vector{Matrix}) -> Bool\n\nDetermines the validity of a set of Kraus operators.\n\nkraus: A vector of matrices, each representing a Kraus operator.\n\nThis function checks if the provided Kraus operators form a valid quantum channel.  It does so by verifying if the sum of the products of each Kraus operator and its adjoint  (approximately) equals the identity matrix. Returns true if the set is valid, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"functions/#BlueTangle.Noise1","page":"Functions","title":"BlueTangle.Noise1","text":"Noise1(model::String, p::Float64)\n\nConstructors for QuantumChannel objects for 1 qubit.\n\nmodel: The noise model type as a string.\np: Probability parameter for the noise model.\n\nReturns a QuantumChannel object.\n\n\n\n\n\n","category":"function"},{"location":"functions/#BlueTangle.Noise2","page":"Functions","title":"BlueTangle.Noise2","text":"Noise2(model::String, p::Float64)\n\nConstructors for QuantumChannel objects for 2 qubits.\n\nmodel: The noise model type as a string.\np: Probability parameter for the noise model.\n\nReturns a QuantumChannel object.\n\n\n\n\n\n","category":"function"},{"location":"functions/#BlueTangle.apply_noise","page":"Functions","title":"BlueTangle.apply_noise","text":"apply noise on qubit or target_qubit of a given state and noise model\n\n\n\n\n\napply noise on qubit or target_qubit of a given density matrix and noise model\n\n\n\n\n\n","category":"function"},{"location":"functions/#BlueTangle.apply_twirl","page":"Functions","title":"BlueTangle.apply_twirl","text":"apply_twirl(op::QuantumOps) -> Vector{QuantumOps}\n\nApplies twirling with specified noise to a single quantum operation.\n\nop: A QuantumOps object representing the quantum operation.\n\nReturns a vector of QuantumOps representing the twirled operation with noise.\n\n\n\n\n\n","category":"function"},{"location":"functions/#BlueTangle.cnot_amplifier!","page":"Functions","title":"BlueTangle.cnot_amplifier!","text":"cnot_amplifier!(ops::Vector{<:QuantumOps}, CNOT_pair=0)\n\nAmplify the presence of CNOT (or CX) operations in a vector of quantum operations.\n\nThis function adds extra pair of CNOT operation in the ops vector a specific number of times in place. This is useful for amplifying the effect of noise via CNOT operations in a sequence of quantum operations.\n\nArguments\n\nops::Vector{<:QuantumOps}: A vector of quantum operations, where T is a subtype of QuantumOps.\nCNOT_pair::Int (optional): The number of additional pairs of CNOT operations to insert for each original CNOT operation in ops. The default value is 0, which means no additional operations are inserted.\n\nExamples\n\nops = [Op(\"H\",1), Op(\"CNOT\",1,2), Op(\"X\",2)]\ncnot_amplifier!(ops, 1)\n# `ops` will be modified to: [Op(\"H\",1), Op(\"CNOT\",1,2), Op(\"CNOT\",1,2), Op(\"CNOT\",1,2), Op(\"X\",2)]\n\n\n\n\n\n","category":"function"},{"location":"functions/#BlueTangle.op_amplifier!","page":"Functions","title":"BlueTangle.op_amplifier!","text":"op_amplifier!(ops::Vector{<:QuantumOps},op_pair=0)\n\nsame as cnot_amplifier! but for all operations\n\n\n\n\n\n","category":"function"},{"location":"functions/#BlueTangle.error_mitigate_data","page":"Functions","title":"BlueTangle.error_mitigate_data","text":"errormitigatedata(xdata::Vector, ydata::Vector)\n\nPerform error mitigation on a dataset by fitting a linear model and extracting the estimate and standard error.\n\nThis function takes two vectors xdata and ydata which represent the independent and dependent variables of a dataset, respectively.\n\nArguments\n\nxdata::Vector: The independent variable data points.\nydata::Vector: The dependent variable data points, corresponding to each xdata point.\n\nReturns\n\nest: The estimated intercept from the linear fit.\nse: The standard error of the estimated intercept.\nfit_plot: A tuple containing the x-values from 0 to the last element of xdata and the corresponding fitted y-values from the model.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Hamiltonian","page":"Functions","title":"Hamiltonian","text":"","category":"section"},{"location":"functions/#BlueTangle.hamiltonian","page":"Functions","title":"BlueTangle.hamiltonian","text":"hamiltonian(N::Int, string_of_ops::Vector, boundary::String=\"open\")\n\nConstructs a Hamiltonian matrix for a quantum system with N qubits. The Hamiltonian is  built based on the operators and their corresponding couplings specified in string_of_ops.\n\nThe string_of_ops should be an alternating array of coupling constants and operator  strings. For example, [.1, \"Z,Z\", .5, \"X\"] implies a system with alternating couplings .1 and .5,  and operators \"Z,Z\" and \"X\".\n\nThe boundary parameter specifies the boundary conditions of the system. It can be either  \"open\" or \"periodic\". In the case of \"open\" boundary conditions, interactions are only included  for sites within the system size. For \"periodic\" boundary conditions, the system is treated as  if it were wrapped around itself, allowing interactions that cross the end and start of the  chain.\n\nArguments\n\nN::Int: The number of qubits in the system.\nstring_of_ops::Vector: An alternating vector of coupling constants and operator strings.\nboundary::String: The boundary condition of the system, either \"open\" or \"periodic\" (default is \"open\").\n\nReturns\n\nSparseMatrix: The Hamiltonian matrix representing the specified quantum system.\n\nExample\n\nN = 6\nstring_of_ops = [-J, \"Z,Z\", -h, \"X\"]\nH = hamiltonian(N, string_of_ops, \"open\")\n\nThis function iterates over the operator strings, applies each operator to the appropriate qubits  based on the boundary conditions, and scales them by their corresponding coupling constants  to construct the Hamiltonian.\n\n\n\n\n\nhamiltonian(rows_cols::Union{Tuple{Int64, Int64},Vector{Int64}}, string_of_ops::Vector, boundary::String=\"open\")\n\nConstructs a 2D Hamiltonian matrix for a quantum system with rows * cols qubits, potentially with double counting.\n\nArguments\n\nrows_cols: A tuple or vector specifying the dimensions of the 2D lattice (rows, columns).\nstring_of_ops::Vector: An alternating vector of coupling constants and operator strings.\nboundary::String: The boundary condition of the system, either \"open\" or \"periodic\" (default is \"open\").\n\nReturns\n\nSparseMatrixCSC: The Hamiltonian matrix representing the specified 2D quantum system.\n\n\n\n\n\n","category":"function"},{"location":"functions/#BlueTangle.hamiltonian_exp","page":"Functions","title":"BlueTangle.hamiltonian_exp","text":"hamiltonian_exp(N::Int, total_time::Float64, string_of_ops::Vector; dt=0.1) -> Vector{QuantumOps}\n\nExpands a given Hamiltonian expressed as a string of operations into a sequence of quantum gates using Trotterization.\n\nN: Number of qubits involved in the simulation.\ntotal_time: The total simulation time over which the Hamiltonian is to be applied.\nstring_of_ops: A vector where odd indices contain the coupling strengths and even indices contain comma-separated strings representing the operators (X, Y, Z) applied to consecutive qubits.\ndt (optional): The time step for Trotterization, with a default value of 0.1.\n\nThe function hamiltonian_exp parses the string_of_ops to construct a sequence of operations based on the specified operators and their coupling strengths. For each term in the Hamiltonian:\n\nThis method returns a vector of QuantumOps, each representing a quantum operation to be applied sequentially to simulate the Hamiltonian over the specified time total_time.\n\nExample\n\nDefine a Hamiltonian for a 3-qubit system with mixed interactions over 2 seconds\n\nN = 3 totaltime = 2.0 stringofops = [1.0, \"X,Y\", 0.5, \"Y,Z\"] ops = hamiltonianexp(N, totaltime, stringof_ops)\n\nops will contain a sequence of quantum gates to apply.\n\n\n\n\n\nhamiltonian_exp(rows_cols::Union{Tuple{Int64, Int64}, Vector{Int64}}, total_time::Float64, string_of_ops::Vector;\n                dt=0.01, full=true, enumeration_style::Symbol=:rowwise) -> Vector{QuantumOps}\n\nGenerate a sequence of quantum operations to simulate a 2D lattice Hamiltonian using Trotterization.\n\nArguments\n\nrows_cols: A tuple or vector specifying the dimensions of the 2D lattice (rows, columns).\ntotal_time: The total simulation time.\nstring_of_ops: A vector alternating between coupling strengths and operator strings.  Each operator string is a comma-separated list of Pauli operators (X, Y, Z) representing  the terms in the Hamiltonian.\n\nKeyword Arguments\n\ndt: Time step for Trotterization (default: 0.01).\nfull: If true, repeats the operation sequence for each Trotter step (default: true).\nenumeration_style: Specifies how qubits are indexed in the 2D lattice.  Options are :rowwise (default) or :colwise.\n\nReturns\n\nA vector of QuantumOps representing the sequence of quantum operations for the simulation.\n\nDetails\n\nThis function implements a Trotterized evolution of a 2D lattice Hamiltonian. It supports arbitrary Pauli string operators and handles both horizontal and vertical nearest-neighbor  interactions in the lattice.\n\nThe Hamiltonian terms are applied to all relevant qubit pairs in the lattice. For operators involving two qubits (e.g., \"X,Y\"), both horizontal and vertical applications are considered. Single-qubit operators are applied to each qubit individually.\n\nThe function uses the _apply_term helper function to generate the specific quantum operations for each term in the Hamiltonian.\n\nExample\n\nrows, cols = 3, 4\ntotal_time = 2.0\nstring_of_ops = [1.0, \"X,Y\", 0.5, \"Z\"]\nops = hamiltonian_exp((rows, cols), total_time, string_of_ops)\n\n\n\n\n\n","category":"function"},{"location":"functions/#BlueTangle.VQE","page":"Functions","title":"BlueTangle.VQE","text":"VQE(opt::AnsatzOptions)\n\nPerforms the Variational Quantum Eigensolver (VQE) algorithm to find the optimal state of a given loss function using the variational quantum circuit defined by the AnsatzOptions.\n\nArguments\n\nopt::AnsatzOptions: The AnsatzOptions object containing the configuration for the variational quantum circuit.\n\nReturns\n\nA tuple containing:\nThe optimization history (energy values) if history=true, otherwise the final energy value.\nThe optimized parameters for the variational circuit.\nThe final state obtained from the optimized parameters.\n\n\n\n\n\n","category":"function"},{"location":"functions/#BlueTangle.variational_apply","page":"Functions","title":"BlueTangle.variational_apply","text":"variational_apply(pars::AbstractVectorS, opt::AnsatzOptions)\n\nApplies the variational quantum circuit defined by the AnsatzOptions to the initial state using the given parameters.\n\nArguments\n\npars::Vector: The parameters for the variational circuit.\nopt::AnsatzOptions: The AnsatzOptions object containing the configuration for the variational circuit.\n\nReturns\n\nThe final state after applying the variational circuit.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Index","page":"Functions","title":"Index","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#1)-GHZ-Circuit","page":"Examples","title":"1) GHZ Circuit","text":"","category":"section"},{"location":"examples/#Overview","page":"Examples","title":"Overview","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This example demonstrates the use of the package for creating a Greenberger–Horne–Zeilinger (GHZ) state circuit.","category":"page"},{"location":"examples/#Example","page":"Examples","title":"Example","text":"","category":"section"},{"location":"examples/#Step-1:-Collect-Quantum-Operations","page":"Examples","title":"Step 1: Collect Quantum Operations","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Define quantum operations to prepare the GHZ state.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using BlueTangle\n\n# Quantum gates\nhadamard = Op(\"H\", 1) # Hadamard gate on the first qubit\ncnot1 = Op(\"CNOT\", 1, 2) # CNOT gate between first and second qubits\ncnot2 = Op(\"CNOT\", 2, 3) # CNOT gate between second and third qubits\n\nops = [hadamard, cnot1, cnot2] # Collect operators","category":"page"},{"location":"examples/#Step-2:-Create-Quantum-Circuit","page":"Examples","title":"Step 2: Create Quantum Circuit","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Next, we compile these operations into a quantum circuit and check its properties.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"circuit = compile(ops) # Create a quantum circuit\nprintln(\"Circuit stats:\", circuit.stats)","category":"page"},{"location":"examples/#2)-Measurement-and-Correlations","page":"Examples","title":"2) Measurement and Correlations","text":"","category":"section"},{"location":"examples/#Overview-2","page":"Examples","title":"Overview","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This section explores two methods for obtaining measurement data and correlations from a quantum circuit, showcasing two distinct approaches:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Sampling Measurement: This approach involves approximating values by taking multiple samples from the quantum circuit.\nExact Calculation using Density Matrix: This method uses the density matrix of the circuit for precise calculations.","category":"page"},{"location":"examples/#Measurement-Sampling-Approach","page":"Examples","title":"Measurement - Sampling Approach","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Perform measurements through sampling and analyse the results. For more details on this function, see measure.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"shots = 1000\nmeasurement1 = measure(circuit, shots) # Sample the circuit\n\nprintln(\"Attributes of the measurement object\",fields(measurement1))\n\n# Output measurement details\nprintln(\"Expectation values:\", measurement1.expect)\nprintln(\"Total magnetization moments:\", measurement1.mag_moments)\n\n# Calculate correlations: ⟨Z₁Z₂⟩\ncorrelations1 = correlation(measurement1, [1, 2])\nprintln(\"Correlations:\", correlations1)","category":"page"},{"location":"examples/#Measurement-Exact-Approach-using-Density-Matrix","page":"Examples","title":"Measurement - Exact Approach using Density Matrix","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Alternatively, we can use the density matrix for exact calculations. Similar one can use state vectors as well, see to_state.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"density_matrix = to_rho(circuit)\n\n# Calculate exact expectation values and correlations\nexpect2 = expect(density_matrix, \"Z\")\ncorrelations2 = correlation(density_matrix, \"Z,Z\", [1, 2]) # Calculate correlations: ⟨Z₁Z₂⟩\n\nprintln(\"Exact expectation values:\", expect2)\nprintln(\"Exact correlations:\", correlations2)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Calculations in Different Bases","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"With the exact density matrix, we can explore correlations in different bases, unlike the sampling measurement.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"expect3 = expect(density_matrix, \"Y\")\ncorrelations3 = correlation(density_matrix, \"Z,X\", [1, 3])\n\nprintln(\"Expectation values <Y>:\", expect3)\nprintln(\"Correlations <Z₁X₃>:\", correlations3)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This example highlights the flexibility and power of the package in quantum circuit analysis and simulation.","category":"page"},{"location":"examples/#3)-Plot-Circuits-and-Measurements","page":"Examples","title":"3) Plot Circuits and Measurements","text":"","category":"section"},{"location":"examples/#Overview-3","page":"Examples","title":"Overview","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The plotq function is designed to create visual representations of quantum circuits, while the plotq function displays the results of quantum measurements. Both of these functions are dependent on the PyPlot package.","category":"page"},{"location":"examples/#Example-2","page":"Examples","title":"Example","text":"","category":"section"},{"location":"examples/#Step-1:-Define-and-Compile-a-Quantum-Circuit","page":"Examples","title":"Step 1: Define and Compile a Quantum Circuit","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Create a simple quantum circuit for demonstration.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using BlueTangle\ninclude(pathof(BlueTangle) * \"../../extra/pyplot.jl\")","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Quantum gates for a basic circuit\nhadamard = Op(\"H\", 1)\ncnot12 = Op(\"CNOT\", 1, 2)\ncnot23 = Op(\"CNOT\", 2, 3)\n\n# Compile the circuit\ncircuit = compile([hadamard, cnot12, cnot23])","category":"page"},{"location":"examples/#Step-2:-Visualize-the-Circuit","page":"Examples","title":"Step 2: Visualize the Circuit","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Use plotq to visualize the circuit structure.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"plotq(circuit)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Step-3:-Perform-Measurements-and-Analyze-Results","page":"Examples","title":"Step 3: Perform Measurements and Analyze Results","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Conduct measurements on the circuit and examine the outcomes.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"measurement = measure(circuit, 1000) # Sample the circuit 1000 times","category":"page"},{"location":"examples/#Step-4:-Plot-Measurement-Results","page":"Examples","title":"Step 4: Plot Measurement Results","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Visualize the measurement data using plotq.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"plotq(measurement)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Troubleshooting-Plotting-Issues","page":"Examples","title":"Troubleshooting Plotting Issues","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"If you encounter problems with plotting, please follow these steps:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Install PyPlot in Julia: Add the PyPlot package to your Julia environment. This package provides an interface to the matplotlib library in Python. You can install it using the Julia package manager:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"import Pkg\nPkg.add(\"PyPlot\")","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Install Python Matplotlib: Ensure that matplotlib is installed in your Python environment. This is a prerequisite for PyPlot as it relies on Python's matplotlib for plotting. You can install matplotlib using pip:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"pip3 install matplotlib","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"For detailed documentation and additional information, refer to the PyPlot GitHub page.","category":"page"},{"location":"examples/#4)-Noise-Models-and-Circuits","page":"Examples","title":"4) Noise Models and Circuits","text":"","category":"section"},{"location":"examples/#Overview-4","page":"Examples","title":"Overview","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This example shows how to create noisy quantum circuits using predefined quantum noise models. The package offers precise control over each quantum operation, allowing for different noise models for individual operations or overall models for single and two-qubit operations.","category":"page"},{"location":"examples/#Predefined-Noise-Models","page":"Examples","title":"Predefined Noise Models","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"amplitude_damping: Simulates energy loss in a quantum system. Parameter γ (given by p) indicates the excitation loss probability.\nphase_damping: Loss of quantum information without energy loss. Parameter γ quantifies the likelihood of a phase shift.\nphase_flip: Introduces phase errors (Z error) with probability p.\nbit_flip: Causes state flips (X error) with probability p.\nbit_phase_flip: Combines bit and phase flips, applying Y error with probability p.\ndepolarizing: General error model where any Pauli operation (X, Y, Z) can occur with equal probability. Parameter p is the overall error probability.\nrot_X, rot_Y, rot_Z, rot_P: Coherent errors (incorrect rotations) around respective axes. Parameter p specifies rotation error magnitude.","category":"page"},{"location":"examples/#Implementing-Noise-in-Circuits","page":"Examples","title":"Implementing Noise in Circuits","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The code below demonstrates how to create a noise model for single qubit gates. The second parameter defines either the amplitude or the probability of the noise model, depending on the selected model. For example:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"noise_model1 = Noise1(\"bit_flip\", 0.001)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this instance, Noise1 constructs a noise model for single qubit operations, specifically a bit flip error, with a probability of 0.001 (or 0.1%).","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Similarly, a noise model for two-qubit operations can be created:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"noise_model2 = Noise2(\"depolarizing\", 0.01)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Here, Noise2 is applied to create a depolarizing channel noise model for two-qubit gates, with an error probability of 0.01 (or 1%).","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can now create the NoiseModel as following","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"nm=NoiseModel(n1,n2)\n\n#Alternatively following constructions give the same result\n\nnm=NoiseModel(\"bit_flip\", 0.001,\"depolarizing\", 0.01)\nnm=NoiseModel([\"bit_flip\", 0.001],[\"depolarizing\", 0.01])","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Next, we will illustrate incorporating these noise models into a quantum circuit.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"ops = [Op(\"H\", 1), Op(\"CNOT\", 1, 2), Op(\"CNOT\", 2, 3)]\nnoisy_circuit = compile(ops, Options(noise=nm))","category":"page"},{"location":"examples/#5)-Custom-Noise-Models-and-Gates","page":"Examples","title":"5) Custom Noise Models and Gates","text":"","category":"section"},{"location":"examples/#Overview-and-Examples","page":"Examples","title":"Overview and Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Predefined constant gates, such as gate[:X], gate[:CNOT] or gate.T, can be easily accessed. For more details, see gate.\nPhase (P) and rotation gates (RX, RY, RZ) can be accessed through gates1(\"RX(.3)\"), or the controlled phase gate via gates(\"CP(.3)\"). Refer to gates and gates for more information. Additionally, all single qubit rotations can be created using U gates with Euler angles, as detailed in _P, _U2, and _U3.\nFor custom defined gates, you can construct your own unitary matrix and create an Op object using the following constructor: Op(\"name_of_my_gate\", matrix, qubit).\nTo create a custom noise model, define your own Kraus operators for a single qubit model using QuantumChannel(1, \"name_of_model\", 0, vector_of_kraus_matrices) or for a two-qubit model with QuantumChannel(2, \"name_of_model\", 0, vector_of_kraus_matrices). It's important to first check if your Kraus operators satisfy the trace-preserving condition using the is_valid_quantum_channel function. Alternatively, you can use the simpler constructor custom_noise(q, name_of_model, vector_of_kraus_matrices), where q is either 1 or 2 for single and two qubit gates, respectively.","category":"page"},{"location":"examples/#6)-Conditional-Mid-Measurements","page":"Examples","title":"6) Conditional Mid-Measurements","text":"","category":"section"},{"location":"examples/#Overview-5","page":"Examples","title":"Overview","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This section introduces the concept and implementation of conditional mid-measurements in quantum circuits. Mid-measurements are powerful tools that allow for conditional execution of quantum operations based on the results of measurements made during the circuit's execution. The application of the Born rule in these measurements adds a probabilistic dimension to the circuit's behaviour.","category":"page"},{"location":"examples/#Conditional-Mid-Measurements-with-ifOp","page":"Examples","title":"Conditional Mid-Measurements with ifOp","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The ifOp function enables conditional mid-measurements. For instance, consider a mid-measurement in the X basis for the first qubit, followed by conditional operations:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"mid_measurement = ifOp(\"MX\", 1, \"Z\", \"H\")\nops = [Op(\"X\", 1), mid_measurement, Op(\"CNOT\", 1, 2), Op(\"CNOT\", 2, 3)]","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Let's break down the example to understand it better:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Function Overview: ifOp","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The ifOp function is used to apply different quantum operations conditionally, depending on the outcome of a mid-circuit measurement.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Setting Up a Conditional Operation:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"In the example, mid_measurement = ifOp(\"MX\", 1, \"Z\", \"H\") defines a conditional operation.\n\"MX\" specifies the measurement basis (here, the X basis).\nThe number 1 indicates that the measurement is performed on the first qubit.\nZ (Z gate) and H (Hadamard gate) are the conditional operations.\nThe function is set up so that if the measurement result of the first qubit in the X basis is 0, the Z gate (Z) is applied. If the result is 1, the Hadamard gate (H) is applied.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Sequence of Operations:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The operations sequence is given by ops = [Op(\"X\", 1), mid_measurement, Op(\"CNOT\", 1, 2), Op(\"CNOT\", 2, 3)].\nOp(\"X\", 1) applies an X gate to the first qubit.\nmid_measurement is then executed, which is the conditional operation defined above.\nFollowing the conditional operation, two CNOT gates are applied: Op(\"CNOT\", 1, 2) entangles the first and second qubits, and Op(\"CNOT\", 2, 3) entangles the second and third qubits.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Outcome:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The outcome of mid_measurement directly influences the state of the circuit after the measurement.\nDepending on the measurement result, the circuit will have either undergone a Hadamard transformation (if the result was 0) or a Z transformation (if the result was 1) on the first qubit before proceeding to the subsequent CNOT gates.","category":"page"},{"location":"examples/#Workout-Example","page":"Examples","title":"Workout Example","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Starting State: The initial state is |000⟩.\nApplication of X Gate: Applying the X gate to the first qubit changes the state to |100⟩.\nConditional Mid-Measurement: When the first qubit is measured in the X basis, the outcome is determined by the Born rule from a superposition state of |000⟩ and -|100⟩. Based on the measurement:\nIf the result is 0, apply a Z gate. The state becomes superposition state of |000⟩ and -|100⟩.\nIf the result is 1, apply a H gate. The state becomes -|100⟩.\nSubsequent CNOT Operations: Applying the first CNOT gate entangles the first and second qubits, and the second CNOT gate entangles the second and third qubits. This results in either the state |111⟩ or (|000⟩ - |111⟩)/√2, each with a 50% probability due to the superposition created by the mid-measurement.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Let's test this using two different methods.","category":"page"},{"location":"examples/#Method-1-Simulation-with-a-Circuit","page":"Examples","title":"Method 1 - Simulation with a Circuit","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"To test the operations, we first compile the circuit and then sample it to obtain a measurement object. The compile function is used to assemble the circuit, and measure is employed to simulate the circuit's execution and generate a Measurement object.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"circuit = compile(ops)\nmeasurement = measure(circuit,1000)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"After obtaining the measurement object, we can visualise the results:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"plotq(measurement)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The measurement results show that half of the time, the state is on 7=|111⟩, and the other half, it is on the GHZ state (7=|111⟩ and 0=|000⟩).","category":"page"},{"location":"examples/#Method-2-Manual-Simulation-with-a-Quantum-Simulator","page":"Examples","title":"Method 2 - Manual Simulation with a Quantum Simulator","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Alternatively, we can manually simulate the same process using a quantum simulator. This approach provides a more hands-on understanding of how each operation affects the state of the quantum system:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"state = zero_state(3) # Initial state for N=3\nstate=apply(state, Op(\"X\", 1)) # Apply X on qubit 1\nstate=apply(state, ifOp(\"MX\", 1, \"Z\", \"H\")) # Measure qubit 1 in X basis. Apply Z if result is 0, H if 1.\nstate=apply(state, Op(\"CNOT\", 1, 2)) # Apply CNOT on qubit 1 and 2\nstate=apply(state, Op(\"CNOT\", 2, 3)) # Apply CNOT on qubit 2 and 3\nstate # Final result: either GHZ state or |111> state.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This manual simulation helps illustrate the probabilistic nature of quantum circuits involving mid-measurements and demonstrates the creation of complex quantum states, such as the GHZ state.","category":"page"},{"location":"examples/#7)-Reset-Operation-on-a-Qubit","page":"Examples","title":"7) Reset Operation on a Qubit","text":"","category":"section"},{"location":"examples/#Overview-6","page":"Examples","title":"Overview","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this example, we demonstrate how to implement a reset operation on a qubit. This operation involves measuring a qubit and, depending on the outcome, applying a corrective operation. Specifically, if the qubit is measured and found to be in the |1⟩ state, an X gate is applied to bring it back to the |0⟩ state. We'll illustrate this concept by creating a Bell state and then resetting the first qubit.","category":"page"},{"location":"examples/#Example-1:-Reset-via-measurement","page":"Examples","title":"Example 1: Reset via measurement","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"First, we start by preparing a Bell state. A Bell state is a maximally entangled quantum state of two qubits. It represents a perfect example of quantum entanglement and is foundational in quantum computing and quantum information theory.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Number of qubits\nN = 2\n\n# Initialising the state vector\nstate = zero_state(N)\n\n# Applying Hadamard gate to the first qubit\nstate=apply(state, Op(\"H\", 1))\n\n# Applying CNOT gate with the first qubit as control and the second as target\nstate=apply(state, Op(\"CX\", 1, 2))\n\n# Show the state of the qubits\ndisplay(state)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"At this point, the system is in a Bell state, which is an equal superposition of |00⟩ and |11⟩ states. You can see this with the following code","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"fock_basis_create(N)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Now, we'll implement the reset operation on the first qubit. This operation involves measuring the first qubit. If the measurement result is |1⟩, we apply the X gate to flip it back to |0⟩. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Reset operation on the first qubit\nop = Op(\"RES\", 1)\napply(state, op)","category":"page"},{"location":"examples/#Understanding-the-Outcome","page":"Examples","title":"Understanding the Outcome","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"After the reset operation, the state of the qubits can be either |00⟩ or |01⟩. The outcome depends on the state of the first qubit at the time of measurement. If the first qubit was in the |0⟩ state (which happens with a 50% probability due to the Bell state's nature), the reset operation does nothing. However, if the first qubit was in the |1⟩ state (again, a 50% chance), the X gate flips it to |0⟩. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Since the second qubit is entangled with the first, its state is correlated. Therefore, measuring the first qubit and applying the reset operation affects the overall state of the two-qubit system. ","category":"page"},{"location":"examples/#8)-Random-Quantum-Circuits","page":"Examples","title":"8) Random Quantum Circuits","text":"","category":"section"},{"location":"examples/#Overview-7","page":"Examples","title":"Overview","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this section, we explore the generation of random quantum circuits, a powerful tool for various quantum computing simulations. The circuits can consist of Clifford gates, a mix of Clifford and non-Clifford gates, and optional mid-circuit measurements in specified bases.","category":"page"},{"location":"examples/#Generating-Random-Clifford-Operations","page":"Examples","title":"Generating Random Clifford Operations","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Define the number of qubits (N) and the length of the quantum circuit (len), then generate a random sequence of Clifford operations:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"N = 3 # Number of qubits\nlen = 5 # Length of the quantum circuit\nrandom_operations = random_clifford(N, len)","category":"page"},{"location":"examples/#Generating-Mixed-Random-Operations","page":"Examples","title":"Generating Mixed Random Operations","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"For a more diverse circuit, generate a random sequence including both Clifford and non-Clifford operations. Note that following code will generate depth=len circuit.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"random_operations = random_ops(N, len)","category":"page"},{"location":"examples/#Including-Mid-Circuit-Measurements","page":"Examples","title":"Including Mid-Circuit Measurements","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The random_clifford function can also incorporate mid-circuit measurements. This is controlled by the measure_prob parameter, which dictates the probability of a measurement occurring after each gate, and the measure_basis parameter, specifying the measurement bases (e.g., \"MX\", \"MY\", \"MZ\").","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"For instance, to create a random sequence of Clifford gates with a 20% chance of measurement in either the \"MX\" or \"MZ\" basis after each gate in a 5-qubit system:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"ops = random_clifford(5, 20; measure_prob=0.2, measure_basis=[\"MX\",\"MZ\"])\nrandom_circuit = compile(ops)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This function will randomly select operations from a set of Clifford gates or measurements, applying them to either single or adjacent qubits. ","category":"page"},{"location":"examples/#Visualizing-the-Random-Circuit","page":"Examples","title":"Visualizing the Random Circuit","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"After generating the random operations, you can visualize the circuit to better understand its structure:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"plotq(random_circuit)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This approach to creating and visualizing random quantum circuits showcases the versatility and capabilities of the package in simulating various quantum computing scenarios.","category":"page"},{"location":"advanced/#Examples","page":"Advanced Examples","title":"Examples","text":"","category":"section"},{"location":"advanced/#9)-Classical-Shadow-Experiment","page":"Advanced Examples","title":"9) Classical Shadow Experiment","text":"","category":"section"},{"location":"advanced/#Overview","page":"Advanced Examples","title":"Overview","text":"","category":"section"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"Classical shadow is a novel technique in quantum computing for efficiently estimating properties of quantum states. In this example, we demonstrate how to use the shadow function to construct a density matrix from the classical shadow representation of a quantum circuit. The technique involves running a series of quantum measurements and using the outcomes to reconstruct an approximation of the quantum state.","category":"page"},{"location":"advanced/#Using-the-shadow-Function","page":"Advanced Examples","title":"Using the shadow Function","text":"","category":"section"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"The shadow function takes two main arguments: a Circuit object and the number of experiments to run. It returns a sparse density matrix representing the classical shadow of the given circuit.","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"The function works by first generating a quantum state from the circuit. It then applies random measurements in one of three bases (\"MX\", \"MY\", \"MZ\") to each qubit. The outcomes of these measurements are used to reconstruct a classical shadow, which is an estimate of the density matrix of the quantum state.","category":"page"},{"location":"advanced/#Example","page":"Advanced Examples","title":"Example","text":"","category":"section"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"Suppose we have a quantum circuit for which we want to estimate the density matrix. We can use the shadow function as follows:","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"# Example Circuit (e.g., a GHZ state circuit)\nN = 3 # Number of qubits\nops = [Op(\"H\", 1), Op(\"CNOT\", 1, 2), Op(\"CNOT\", 2, 3)]\ncircuit = compile(ops)\n\n# Running the classical shadow experiment\nnumber_of_experiments = 1000\n\n# Estimated Density Matrix from Classical Shadow:\ndensity_matrix = shadow(circuit, number_of_experiments)","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"This example demonstrates generating a density matrix estimate for a 3-qubit system using 1000 experiments. The shadow function will perform the necessary quantum state preparations, measurements, and reconstructions to provide an efficient approximation of the density matrix.","category":"page"},{"location":"advanced/#Utilizing-the-Estimated-Density-Matrix","page":"Advanced Examples","title":"Utilizing the Estimated Density Matrix","text":"","category":"section"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"With the estimated density matrix from the classical shadow, you can now calculate various quantum properties. Use density_matrix to compute correlations, expected values, and even entanglement entropy. Refer to functions like expect for expectation values, correlation for correlations, and entanglement_entropy for quantifying entanglement.","category":"page"},{"location":"advanced/#Conclusion","page":"Advanced Examples","title":"Conclusion","text":"","category":"section"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"The classical shadow technique, as implemented in the shadow function, is an efficient method for estimating properties of quantum states, particularly useful in scenarios where full quantum state tomography would be too resource-intensive. While classical shadows offer an efficient alternative to full state tomography, the accuracy of the reconstruction depends on the number of experiments. A higher number of experiments typically leads to a more accurate estimation but requires more computational resources.","category":"page"},{"location":"advanced/#10)-Entanglement-Entropy-and-Spectrum","page":"Advanced Examples","title":"10) Entanglement Entropy and Spectrum","text":"","category":"section"},{"location":"advanced/#Overview-2","page":"Advanced Examples","title":"Overview","text":"","category":"section"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"Entanglement entropy is a fundamental measure in quantum information theory, indicating the degree of entanglement in quantum states. This section demonstrates how to calculate entanglement entropy and spectrum using state vectors or density matrices from quantum circuits, either built step-by-step or obtained via classical shadows.","category":"page"},{"location":"advanced/#Entanglement-Entropy-from-State-Vectors","page":"Advanced Examples","title":"Entanglement Entropy from State Vectors","text":"","category":"section"},{"location":"advanced/#Example-Using-'apply'","page":"Advanced Examples","title":"Example - Using 'apply'","text":"","category":"section"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"Let's build a random state and calculate the bipartite entanglement.","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"N=4\nstate = zero_state(4)\n\nops=random_ops(N,20)\n\nfor op=ops\n    state=apply(state,op)\nend\n\n# Calculate the entanglement entropy\nent_entropy, ent_spectrum = entanglement_entropy(state)\nprintln(\"Entanglement Entropy:\", ent_entropy)\nprintln(\"Entanglement Spectrum:\", ent_spectrum)","category":"page"},{"location":"advanced/#Entanglement-Entropy-from-Density-Matrices","page":"Advanced Examples","title":"Entanglement Entropy from Density Matrices","text":"","category":"section"},{"location":"advanced/#Example-Using-'to_rho'","page":"Advanced Examples","title":"Example - Using 'to_rho'","text":"","category":"section"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"For the same GHZ circuit:","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"circuit = compile(ops)\nrho = to_rho(circuit)\n\n# Convert circuit to density matrix\nrho = to_rho(circuit)\n\n# Calculate entanglement entropy\nent_entropy_rho, ent_spectrum_rho = entanglement_entropy(rho)\nprintln(\"Entanglement Entropy from rho:\", ent_entropy_rho)\nprintln(\"Entanglement Spectrum from rho:\", ent_spectrum_rho)","category":"page"},{"location":"advanced/#Conclusion-2","page":"Advanced Examples","title":"Conclusion","text":"","category":"section"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"This section demonstrates practical ways to calculate entanglement entropy and spectrum, whether from direct state vector manipulation, standard quantum circuit density matrices, or density matrices derived from classical shadows. When working with noisy or imperfect quantum systems, the calculated entanglement entropy and spectrum should be interpreted with care.","category":"page"},{"location":"advanced/#11)-Time-Evolution-of-Hamiltonians","page":"Advanced Examples","title":"11) Time Evolution of Hamiltonians","text":"","category":"section"},{"location":"advanced/#Overview-3","page":"Advanced Examples","title":"Overview","text":"","category":"section"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"In this section, we will explore how to simulate the time evolution of a quantum system under a given Hamiltonian using the Trotterization technique. This process involves creating a quantum circuit that approximates the evolution of the system over time. We'll demonstrate this using the example of an Ising model Hamiltonian.","category":"page"},{"location":"advanced/#Example:-Ising-Model-Hamiltonian","page":"Advanced Examples","title":"Example: Ising Model Hamiltonian","text":"","category":"section"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"Consider a one-dimensional Ising model described by the Hamiltonian:","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"H = -J sum sigma^x_i sigma^x_i+1 - h sum sigma^z_i","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"where J is the coupling constant for the interaction between adjacent qubits, h is the magnetic field strength applied in the Z-direction, and the sums run over all sites in the chain.","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"# Parameters for the Ising Hamiltonian\nN = 4 # Number of qubits in the Ising chain\nJ = -1.0 # Coupling constant\nh = -0.8 # Magnetic field strength\ntotal_time = 0.6 # Total simulation time\n\nstring_hamiltonian = [J, \"X,X\", h, \"Z\"]","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"To simulate the time evolution under this Hamiltonian, we use the hamiltonian_exp function, which takes the number of qubits, total simulation time, and the Hamiltonian expressed as a string of operations. It returns a sequence of Trotterized quantum operations.","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"ops = hamiltonian_exp(N, total_time, string_hamiltonian) # Trotterized operations for evolution of Hamiltonian\nc = compile(ops)","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"We can then run the quantum circuit and perform measurements:","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"shots = 10000\nm = measure(c, shots)","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"To visualize the first few layers of the Trotterized circuit:","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"plotq(c.layers[1:16]) # First 16 layers","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"(Image: )","category":"page"},{"location":"advanced/#Comparison-with-Exact-Evolution","page":"Advanced Examples","title":"Comparison with Exact Evolution","text":"","category":"section"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"To compare the Trotterized evolution with the exact evolution, we can calculate the final state using matrix exponentiation:","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"H_mat = hamiltonian(N, string_hamiltonian) # Hilbert representation of the Hamiltonian\nfinal_state = sa.sparse(exp(-im * total_time * Matrix(H_mat)) * zero_state(N))\nm2 = measure(final_state) # Get exact measurement object from state vector","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"We can then plot the measurement results from both the Trotterized circuit and the exact calculation:","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"plotq([m, m2], [\"Trotterized Circuit\", \"Exact Measurement\"]) # Compare measurements","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"(Image: )","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"To further analyze the results, we can plot the expectation values of the Z operator for each qubit:","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"fig, ax = subplots(1, 1, dpi=100)\n\nax.plot(m.expect, \"ro\", label=\"Trotterized Circuit\")\nax.plot(m2.expect, \"bx\", label=\"Exact Measurement\")\n\nlegend()\nxlabel(\"Qubit\")\nylabel(L\"\\langle Z \\rangle\")\nylim(0, 1)\n\nfig","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"(Image: )","category":"page"},{"location":"advanced/#Conclusion-3","page":"Advanced Examples","title":"Conclusion","text":"","category":"section"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"Trotterization is a powerful technique for simulating the time evolution of quantum systems under a given Hamiltonian. By breaking down the evolution into small time steps and applying a sequence of quantum gates, we can approximate the dynamics of the system. The hamiltonian_exp function in the BlueTangle package provides a convenient way to generate the Trotterized quantum circuit from a Hamiltonian expressed as a string of operations.","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"Comparing the Trotterized evolution with the exact calculation allows us to assess the accuracy of the approximation. The agreement between the two results depends on the size of the time step and the total simulation time. Smaller time steps generally lead to better approximations but also increase the circuit depth.","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"Trotterization is especially useful when the exact evolution is computationally expensive or infeasible, as is often the case for large quantum systems. It enables the study of quantum dynamics on near-term quantum devices and classical simulators.","category":"page"},{"location":"advanced/#12)-Error-Mitigation:-Pauli-Twirling","page":"Advanced Examples","title":"12) Error Mitigation: Pauli Twirling","text":"","category":"section"},{"location":"advanced/#Overview-4","page":"Advanced Examples","title":"Overview","text":"","category":"section"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"In the era of NISQ quantum simulations implementing effective error mitigation strategies is essential. Pauli Twirling is a common technique that converts coherent errors into stochastic ones. However, it's important to note that while Pauli Twirling is effective in addressing certain errors, it does not completely remove existing biases in the simulation. Moreover, the process of twirling itself can be noisy, reflecting a more realistic scenario of quantum operations but also complicating the error landscape.","category":"page"},{"location":"advanced/#Setting-Up-the-Circuit-with-Rotation-Errors","page":"Advanced Examples","title":"Setting Up the Circuit with Rotation Errors","text":"","category":"section"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"We start by creating a quantum circuit with a coherent noise model. This section provides a comprehensive example demonstrating the implementation of error mitigation using Pauli Twirling in a quantum simulation.","category":"page"},{"location":"advanced/#Setting-Up-the-Circuit-with-Rotation-Errors-2","page":"Advanced Examples","title":"Setting Up the Circuit with Rotation Errors","text":"","category":"section"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"First, we define a coherent noise model, specifically rotation errors, and apply this noise to a series of quantum operations.","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"rot_angle = 0.2\nn1 = Noise1(\"rot_z\", 0.1 * rot_angle * pi)\nn2 = Noise2(\"rot_z\", rot_angle * pi)\n# Creating a noise model for rotation errors\nnm=NoiseModel(n1,n2)\n\n# Defining a series of quantum operations\nops = [Op(\"H\", 1), Op(\"H\", 2), Op(\"CNOT\", 1, 2), Op(\"CNOT\", 2, 1), Op(\"H\", 1), Op(\"H\", 2)]","category":"page"},{"location":"advanced/#Creating-and-Comparing-Circuits","page":"Advanced Examples","title":"Creating and Comparing Circuits","text":"","category":"section"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"We construct three quantum circuits: an exact circuit without noise, a noisy circuit, and a circuit with Pauli Twirling applied. Each circuit is then visualized for comparison.","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"Exact Circuit: A noise-free version of the circuit.\nNoisy Circuit: The same circuit with rotation errors applied.\nNoisy Twirl Circuit: The circuit with both rotation errors and Pauli Twirling applied.","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"# Creating the exact circuit\nopt_exact = Options(circuit_name=\"exact\")\ncircuit_exact = compile(ops,opt_exact)\n\n# Creating the noisy circuit\nopt_noisy = Options(circuit_name=\"noisy\", noise=nm)\ncircuit_noisy = compile(ops,opt_noisy)\n\n# Creating the noisy circuit with Pauli Twirling\nopt_twirl = Options(circuit_name=\"twirl\", twirl=true, noise=nm)\ncircuit_twirl = compile(ops, opt_twirl)\n\nplotq(circuit_noisy)","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"(Image: )","category":"page"},{"location":"advanced/#Measurement-and-Analysis","page":"Advanced Examples","title":"Measurement and Analysis","text":"","category":"section"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"Finally, let's measure each circuit and plot the results to analyze the effects of noise and error mitigation method.","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"# Setting the number of samples for measurement\nnum_samples = 1000\n\n# Conducting measurements on the circuits\nmeasurement_exact = measure(circuit_exact, num_samples)\nmeasurement_noisy = measure(circuit_noisy, num_samples)\nmeasurement_twirl = measure(circuit_twirl, num_samples)\n\n# Plotting the measurement results\nplotq([measurement_exact, measurement_noisy, measurement_twirl])","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"(Image: )","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"The resulting plots provide a visual comparison of the measurement outcomes across the three scenarios: exact, noisy, and noisy with Pauli Twirling. This helps to evaluate the effectiveness of error mitigation strategies in NISQ quantum simulations. It's important to recognize the trade-offs involved: while twirling can reduce the impact of coherent errors, it may introduce new noise sources and biases, which must be carefully considered in the analysis of the simulation results.","category":"page"},{"location":"advanced/#13)-Error-Mitigation:-Zero-Noise-Extrapolation","page":"Advanced Examples","title":"13) Error Mitigation: Zero-Noise Extrapolation","text":"","category":"section"},{"location":"advanced/#Overview-5","page":"Advanced Examples","title":"Overview","text":"","category":"section"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"Zero-Noise Extrapolation (ZNE) is a powerful technique for error mitigation in quantum simulations. This method strategically scales the noise in a quantum circuit upwards and then extrapolates back to a theoretical zero-noise scenario, thereby enhancing the precision of quantum computations. In this package, implementing ZNE is straightforward and can be activated with a simple option in the circuit compilation process, such as Options(zne=true). When this option is enabled, the compiler automatically introduces additional noise by inserting pairs of CNOT gates. Consequently, the sample function yields four distinct measurement objects, each corresponding to a different level of noise amplification.","category":"page"},{"location":"advanced/#Example-1:-Setting-Up-the-Circuit-with-Rotation-Errors","page":"Advanced Examples","title":"Example 1: Setting Up the Circuit with Rotation Errors","text":"","category":"section"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"We start by creating a quantum circuit with a basic noise model.","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"p = 0.05\nn1 = Noise1(\"rot_Z\", 0.1 * p * pi)\nn2 = Noise2(\"rot_Z\", p * pi)\n# Creating two noise models for rotation errors\nnm=NoiseModel(n1,n2)\n\n# Defining a series of quantum operations\nops = [Op(\"H\", 1), Op(\"H\", 2), Op(\"CNOT\", 1, 2), Op(\"CNOT\", 2, 1), Op(\"H\", 1), Op(\"H\", 2)]","category":"page"},{"location":"advanced/#Creating-and-Analyzing-Different-Circuits","page":"Advanced Examples","title":"Creating and Analyzing Different Circuits","text":"","category":"section"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"We construct multiple quantum circuits: an exact circuit without noise, a noisy circuit, a circuit with twirling, one with ZNE, and another combining twirling and ZNE.","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"# Creating the exact circuit\nopt_exact = Options(circuit_name=\"exact\", noise=nm)\ncircuit_exact = compile(ops,opt_exact)\n\n# Creating the noisy circuit\nopt_noisy = Options(circuit_name=\"noisy\", noise=nm)\ncircuit_noisy = compile(ops,opt_noisy)\nplotq(circuit_noisy)\n\nopt_twirl = Options(circuit_name=\"twirl\", noise=nm, twirl=true)\ncircuit_twirl = compile(ops, opt_twirl)","category":"page"},{"location":"advanced/#Measurement-and-Analysis-2","page":"Advanced Examples","title":"Measurement and Analysis","text":"","category":"section"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"We measure each circuit and analyze the results to evaluate the effectiveness of Zero-Noise Extrapolation and its combination with Pauli Twirling.","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"shots=10000\n# Conducting measurements on the circuits\nm_exact = measure(circuit_exact, shots)\nm_noisy = measure(circuit_noisy, shots)\nm_zne = measure_ZNE(circuit_twirl, shots) # Multiple measurements for different noise levels","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"Now we plot and compare these results together with error mitigated result.","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"# Analysis of results using magnetization moments\nusing PyPlot\n\nm_order = 1 #first magnetization moment\nfig = figure()\n\nydata = [m.mag_moments[m_order] for m in m_zne]\nxdata = collect(1:2:2length(ydata))\n\nplot(xdata, ydata, \"ro\", label=\"Twirl and ZNE\")\nest, se, fit_plot = error_mitigate_data(xdata, ydata)\n\nplot(fit_plot..., alpha=.5, color=\"red\", \"--\")\nplot(est, \"rx\", label=\"Error mitigated\")\naxhline(est + se, color=\"red\", lw=1)\naxhline(est - se, color=\"red\", lw=1)\nfill_between(-.1:1, est + se, est - se, color=\"red\", alpha=0.1)\n\nplot(m_exact.mag_moments[m_order], color=\"blue\", \"x\", label=\"Exact\")\nplot(m_noisy.mag_moments[m_order], color=\"green\", \"s\", label=\"Noisy\")\nplot(m_zne.mag_moments[m_order], color=\"black\", \"d\", label=\"Twirl\")\nlegend()\n\nxlabel(\"Noise Level\")\nylabel(\"Magnetization (Z)\")\nfig","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"(Image: )","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"This example demonstrates how Zero-Noise Extrapolation, both independently and in conjunction with Pauli Twirling, can be implemented in quantum simulations to mitigate errors. The resulting analysis provides insights into the comparative effectiveness of these techniques in improving the accuracy of quantum computations in NISQ environments.","category":"page"},{"location":"advanced/#Example-2:-Implementing-Manual-Noise-Amplification","page":"Advanced Examples","title":"Example 2: Implementing Manual Noise Amplification","text":"","category":"section"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"In this approach, we manually increase the noise in the circuit by adding pairs of CNOT gates. This is achieved using the functions cnot_amplifier! or op_amplifier!, as referenced in the documentation. This manual amplification provides us with precise control over the noise levels, a critical aspect for implementing ZNE effectively. The ability to control the level of noise added makes this approach particularly advantageous for advanced users who require fine-tuned noise scaling in their quantum simulations.","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"# Applying manual noise amplification\nm_zne = Vector{Measurement}()\nfor i = 0:2 #i=0 gives exact\n    ops = [Op(\"H\", 1), Op(\"H\", 2), Op(\"CNOT\", 1, 2), Op(\"CNOT\", 2, 1), Op(\"H\", 1), Op(\"H\", 2)] # Initial operators\n    cnot_amplifier!(ops, i)\n    circuit=compile(ops, Options(twirl=true, noise=nm)\n    push!(m_zne, measure(circuit, 1000))\nend","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"We can then conduct a similar analysis for the measurement results obtained from the manually noise-amplified circuits.","category":"page"},{"location":"advanced/#14)-Error-Mitigation:-Measurement-Errors","page":"Advanced Examples","title":"14) Error Mitigation: Measurement Errors","text":"","category":"section"},{"location":"advanced/#Overview-6","page":"Advanced Examples","title":"Overview","text":"","category":"section"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"Measurement errors are a significant source of inaccuracies in quantum simulations, especially in NISQ devices. Mitigating these errors is crucial for obtaining reliable results. The technique described in the Qiskit documentation involves creating a calibration matrix from a set of calibration circuits and then using this matrix to adjust the results of quantum measurements. The following example demonstrates how to implement this technique with BlueTangle.jl package.","category":"page"},{"location":"advanced/#Example:-Mitigating-Measurement-Errors","page":"Advanced Examples","title":"Example: Mitigating Measurement Errors","text":"","category":"section"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"We will create a quantum circuit with measurement errors, apply a mitigation strategy, and then compare the results with and without mitigation.","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"# Defining the operations and the measurement error\nops = [Op(\"H\", 1), Op(\"CNOT\", 1, 2)]\nmeasurement_err = Noise1(\"bit_flip\", 0.1) #this can be any other noise model as well.\n\n# Compiling the circuits\nce = compile(ops) # Exact circuit with no measurement error\ncn = compile(ops, Options(readout_noise=m1)) # Circuit with measurement errors\ncm = compile(ops, Options(readout_noise=m1, measurement_mitigate=true)) # Circuit with measurement errors and mitigation\n\n# Performing measurements\nshots = 1000\nme = measure(ce, shots)\nmn = measure(cn, shots)\nmm = measure(cm, shots)\n\n# Plotting the measurement results\nplotq([me,mn,mm],[\"no error\",\"measurement error\",\"error mitigated measurement\"])","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"(Image: )","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"This example illustrates how measurement error mitigation can be incorporated into quantum simulations to improve the accuracy of the results.","category":"page"},{"location":"advanced/#15)-Layout-and-Nonlocal-Swaps-during-Circuit-Compilation","page":"Advanced Examples","title":"15) Layout and Nonlocal Swaps during Circuit Compilation","text":"","category":"section"},{"location":"advanced/#Overview-7","page":"Advanced Examples","title":"Overview","text":"","category":"section"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"When compiling quantum circuits for execution on physical quantum devices, it's essential to consider the connectivity constraints of the hardware. Not all qubits can directly interact with each other, and this limitation is captured by the device's qubit layout or topology. In this example, I will demonstrate how to define a custom qubit layout and how the compiler handles nonlocal operations by automatically inserting swap gates when necessary.","category":"page"},{"location":"advanced/#Example:-Custom-Qubit-Layout-and-Nonlocal-Operations","page":"Advanced Examples","title":"Example: Custom Qubit Layout and Nonlocal Operations","text":"","category":"section"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"First, we define a custom qubit layout using a sparse matrix. Each nonzero entry in the matrix represents a connection between the corresponding qubits.","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"qubit_grid = sa.SparseMatrixCSC([\n    1 0 1 0;\n    1 1 1 0;\n    0 1 0 1;\n    0 1 1 1;\n])\n\nl = Layout(qubit_grid) # Create layout object","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"We can visualize the layout geometry:","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"l.geometry # You can see the layout geometry later with this code","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"Next, let's define a quantum circuit with a nonlocal operation:","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"ops = [Op(\"CNOT\", 3, 10), Op(\"H\", 2), Op(\"X\", 3)] # In this case, the CNOT gate between qubits 3 and 10 are not neighbors on the layout, so necessary swap gates will be implemented.","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"When we compile the circuit with the custom layout, the compiler detects the nonlocal operation and automatically inserts swap gates:","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"c = compile(ops; layout=l) # Nonlocal operation detected. Swap will be inserted.\nplotq(c)","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"(Image: )","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"Now, let's consider a circuit where all operations are local with respect to the layout:","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"ops = [Op(\"CNOT\", 3, 7), Op(\"H\", 2), Op(\"X\", 3)] # In this case, the CNOT gate between qubits 3 and 7 are neighbors on the layout, so no swap gates are needed.","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"Compiling this circuit with the same layout doesn't require any additional swap gates:","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"c = compile(ops; layout=l)\nplotq(c) # In this case, swaps are not needed due to the layout.","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"(Image: )","category":"page"},{"location":"advanced/#Nonlocal-Control-Operations","page":"Advanced Examples","title":"Nonlocal Control Operations","text":"","category":"section"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"It's important to note that when we add a control parameter to an operation, it doesn't matter about locality. The compiler will always allow nonlocal control operations without inserting swap gates. For example:","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"ops = [Op(\"X\", 3; control=1), Op(\"Y\", 7; control=1), Op(\"Z\", 6; control=4)]\nc = compile(ops; layout=l)\nplotq(c) # No swaps are inserted for nonlocal control operations","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"(Image: )","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"This behaviour is intentional and allows for the implementation of long-range interactions and global gates in quantum circuits.","category":"page"},{"location":"advanced/#Conclusion-4","page":"Advanced Examples","title":"Conclusion","text":"","category":"section"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"This example illustrates how the qubit layout affects the compilation of quantum circuits. When the circuit contains nonlocal operations with respect to the layout, the compiler automatically inserts swap gates to ensure the operations can be executed on the hardware. On the other hand, when all operations are local, no additional swap gates are needed. This automatic handling of nonlocal operations simplifies the process of adapting quantum circuits to the constraints of physical devices. The ability to define custom qubit layouts allows for the simulation of circuits on hardware with various connectivity topologies.","category":"page"},{"location":"advanced/#16)-Hadamard-Test","page":"Advanced Examples","title":"16) Hadamard Test","text":"","category":"section"},{"location":"advanced/#Mathematical-Background","page":"Advanced Examples","title":"Mathematical Background","text":"","category":"section"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"The Hadamard test is a quantum algorithm that estimates the real part of the expectation value of a unitary operator U with respect to a quantum state psirangle. Mathematically, it computes:","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"textRe(langlepsiUpsirangle) = textPr(0) - textPr(1)","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"where textPr(0) and textPr(1) are the probabilities of measuring the ancilla qubit in the 0rangle and 1rangle states, respectively.","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"The circuit for the Hadamard test involves an ancilla qubit and the unitary operator U controlled by the ancilla qubit. The steps are as follows:","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"Prepare the ancilla qubit in the 0rangle state and the system qubit(s) in the state psirangle.\nApply a Hadamard gate to the ancilla qubit.\nApply the controlled-U operation, with the ancilla qubit as the control and the system qubit(s) as the target(s).\nApply another Hadamard gate to the ancilla qubit.\nMeasure the ancilla qubit in the computational basis.","category":"page"},{"location":"advanced/#Example-2","page":"Advanced Examples","title":"Example","text":"","category":"section"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"Let's consider a simple example where we want to estimate the expectation value of the Pauli Z operator on a single qubit in the 1rangle state. In this case, U = Z and psirangle = 1rangle.","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"We can create the Hadamard test circuit using the following code:","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"# Define the operators\nops=[Op(\"X\", 2), Op(\"H\", 1), Op(\"Z\", 2; control=1), Op(\"H\", 1)]\n\n# Plot the circuit\nplotq(ops)","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"(Image: )","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"In this circuit, qubit 1 is the ancilla qubit, and qubit 2 is the system qubit. The steps are:","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"The ancilla qubit is prepared in the +rangle state by applying a Hadamard gate to the 0rangle state.\nThe system qubit is prepared in the 1rangle state by applying an X gate to the 0rangle state.\nA Hadamard gate is applied to the ancilla qubit.\nThe controlled-Z operation is applied, with the ancilla qubit controlling the Z gate on the system qubit.\nAnother Hadamard gate is applied to the ancilla qubit.","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"We can then measure the ancilla qubit multiple times to estimate the probabilities textPr(0) and textPr(1):","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"# Measure the circuit\nnum_shots = 1000\n\nstate=zero_state(2)\nfor o=ops\n    state=apply(state,o)\nend\n\nancilla=1\npr_0,pr_1=prob(state,num_shots,ancilla) # Estimate the probabilities\n\n# Compute the expectation value\nexpectation_value = pr_0 - pr_1\nprintln(\"Estimated <Z> = \", expectation_value)","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"In this case, we expect the output to be close to -1, since langle1Z1rangle = -1.","category":"page"},{"location":"advanced/#Conclusion-5","page":"Advanced Examples","title":"Conclusion","text":"","category":"section"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"The Hadamard test is a powerful tool for estimating expectation values of unitary operators on quantum states. By using an ancilla qubit and controlled operations, we can indirectly measure the real part of the expectation value. This technique has widespread applications in quantum algorithms, such as in the Variational Quantum Eigensolver (VQE) for estimating the energy of a quantum system.","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"The BlueTangle package in Julia provides an intuitive way to construct and simulate Hadamard test circuits. The control keyword argument allows for easy creation of controlled operations, enabling the implementation of the Hadamard test and other quantum algorithms involving controlled unitaries.","category":"page"},{"location":"advanced/#17)-Swap-Test","page":"Advanced Examples","title":"17) Swap Test","text":"","category":"section"},{"location":"advanced/#Mathematical-Background-2","page":"Advanced Examples","title":"Mathematical Background","text":"","category":"section"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"The Swap test is a quantum algorithm that estimates the overlap (inner product) between two quantum states psirangle and phirangle. Mathematically, it computes:","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"langlepsiphirangle^2 = 2textPr(0) - 1","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"where textPr(0) is the probability of measuring the ancilla qubit in the 0rangle state.","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"The circuit for the Swap test involves an ancilla qubit and a controlled-SWAP operation between the two quantum states. The steps are as follows:","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"Prepare the ancilla qubit in the 0rangle state and the system qubits in the states psirangle and phirangle.\nApply a Hadamard gate to the ancilla qubit.\nApply the controlled-SWAP operation, with the ancilla qubit as the control and the system qubits as the targets.\nApply another Hadamard gate to the ancilla qubit.\nMeasure the ancilla qubit in the computational basis.","category":"page"},{"location":"advanced/#Example-3","page":"Advanced Examples","title":"Example","text":"","category":"section"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"Let's consider an example where we want to estimate the overlap between the states psirangle = 0rangle and phirangle = frac1sqrt2(0rangle + 1rangle).","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"We can create the Swap test circuit using the following code:","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"# Define the operators\nh = Op(\"H\", 1)\nswap = Op(\"SWAP\", 2, 3; control=1)\n\nops=[\n    Op(\"X\", 2), \n    Op(\"H\", 3), \n    h, \n    swap, \n    h\n]\n\n# Plot the circuit\nplotq(ops)","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"(Image: )","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"In this circuit:","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"Qubit 1: Ancilla qubit.\nQubit 2: System qubit prepared in the state psirangle.\nQubit 3: System qubit prepared in the state phirangle.","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"The steps are:","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"The system qubit 2 is prepared in the state psirangle by applying an X gate.\nThe system qubit 3 is prepared in the state phirangle by applying an H gate.\nA Hadamard gate is applied to the ancilla qubit.\nThe controlled-SWAP operation is applied, with the ancilla qubit controlling the SWAP operation between qubits 2 and 3.\nAnother Hadamard gate is applied to the ancilla qubit.","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"We can then measure the ancilla qubit multiple times to estimate the probability textPr(0):","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"state=zero_state(3)\nfor o=ops\n    state=apply(state,o)\nend\n\n# Estimate the probability\nnum_shots = 1000\nancilla=1\npr_0,pr_1 = prob(state,num_shots,ancilla)\n\n# Compute the overlap\noverlap = 1 - 2 * pr_1\n# overlap = 2 * pr_0 - 1\n\nprintln(\"Estimated |<ψ|ϕ>|^2 = \", overlap)","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"In this case, we expect the output to be close to 0.5, since langle0frac1sqrt2(0rangle + 1rangle)^2 = 05.","category":"page"},{"location":"advanced/#Conclusion-6","page":"Advanced Examples","title":"Conclusion","text":"","category":"section"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"The Swap test is a quantum algorithm that estimates the overlap between two quantum states. By using an ancilla qubit and a controlled-SWAP operation, we can indirectly measure the magnitude squared of the inner product between the states. This technique has applications in quantum machine learning, quantum state comparison, and quantum state tomography.","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"The BlueTangle package in Julia provides a straightforward way to construct and simulate Swap test circuits. The control keyword argument enables the easy creation of controlled operations, allowing for the implementation of the Swap test and other quantum algorithms involving controlled gates.","category":"page"},{"location":"advanced/#18)-Variational-Quantum-Eigensolver","page":"Advanced Examples","title":"18) Variational Quantum Eigensolver","text":"","category":"section"},{"location":"advanced/#Overview-8","page":"Advanced Examples","title":"Overview","text":"","category":"section"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"The Variational Quantum Eigensolver (VQE) is a hybrid quantum-classical algorithm used to find the lowest eigenvalue of a given Hamiltonian. It's particularly useful for quantum chemistry and optimization problems. In this example, we'll demonstrate how to use VQE to find the ground state energy of a quantum system described by a specific Hamiltonian. We'll also show how to calculate the entanglement entropy of the resulting state.","category":"page"},{"location":"advanced/#Example:-VQE-for-a-1D-Transverse-Field-Ising-Model","page":"Advanced Examples","title":"Example: VQE for a 1D Transverse Field Ising Model","text":"","category":"section"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"Consider a one-dimensional transverse field Ising model described by the Hamiltonian:","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"H = -J sum sigma^z_i sigma^z_i+1 - h sum sigma^x_i","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"where J is the interaction strength, h is the transverse field strength, and the sums run over all sites in the chain.","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"N = 5  # Number of qubits in the Ising chain\nJ = -1.0          # Coupling constant\nh = -.9         # Magnetic field strength\n\nstring_hamiltonian=[J,\"Z,Z\",h,\"X\"]\n\nH = hamiltonian(N, string_hamiltonian); #Hamiltonian\n\n# Calculating the exact ground state energy for comparison\nme = la.eigen(Matrix(H)).values[1]","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"Next, we set up the VQE algorithm:","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"gate_list = [\"RY\", \"CNOT\"] # Ansatz consisting of RY and CNOT gates\n\nansatz = AnsatzOptions(\n    N = N,\n    deep_circuit = true, # Use a deep circuit ansatz\n    ops = gate_list,\n    loss = H,\n    model = \"lbfgs\" # Using the momentum optimiser\n)\n\nplotq(ansatz)","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"(Image: )","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"VQE algorithm can be run as following","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"en, pars = VQE(ansatz) # Running the VQE algorithm","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"We can plot the convergence of the VQE algorithm:","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"fig = figure()\n\nplot(1:length(en), en, \"rp\", label=\"$(ansatz.model)=$(ro3(en[end]))\")\naxhline(me, label=\"exact=$(ro3(me))\", c=\"blue\")\nlegend()\nfig","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"(Image: )","category":"page"},{"location":"advanced/#Using-Custom-Operations","page":"Advanced Examples","title":"Using Custom Operations","text":"","category":"section"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"You can also include your own set of operations when creating the AnsatzOptions object. For example:","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"ops = [[Op(\"RY\", _RY, i) for i=1:N]..., Op(\"CNOT\", 3, 4), Op(\"CNOT\", 3, 4; control=1),\nOp(\"RY\", _RY, 4; control=1), Op(\"RY\", _RY, 3; control=5), Op(\"FSIM\", _FSIM, 2, 3),\nOp(\"FSIM\", _FSIM, 4, 5)]\n\nansatz = AnsatzOptions(\n    N = N,\n    pars_initial = ones(100), # Initial parameters\n    ops = ops,\n    loss = H,\n    model = \"lbfgs\" # Using the L-BFGS optimiser\n)\n\nplotq(ansatz.ops)","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"(Image: )","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"The procedure for using custom operations is the same as before. Simply create an AnsatzOptions object with your custom operations. Note that when creating your own set of operators, you need to use Op(\"name\", function_that_gives_matrix, qubit) for single-qubit operations Op(\"name\", function_that_gives_matrix, qubit1, qubit2) for two-qubit operations or Op(\"name\", function_that_gives_matrix, qubit;control=control_qubit) for nonlocal controlled operations.","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"After creating the AnsatzOptions object, you can access its details. For example:","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"ansatz.ops gives the operators used in the ansatz.\nplotq(ansatz) plots the ansatz circuit using \nansatz.dim gives the dimension of the ansatz, i.e., the number of fitting parameters.\nansatz.method gives the method used in the optimisation. Other examples are adam, descent, radam, momentum, nesterov, lbfgs.","category":"page"},{"location":"advanced/#Calculating-Entanglement-Entropy","page":"Advanced Examples","title":"Calculating Entanglement Entropy","text":"","category":"section"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"After obtaining the ground state from the VQE algorithm, we can calculate its entanglement entropy.","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"# Obtaining the ground state\nground_state = variational_apply(pars, ansatz)\n\n# Calculating the entanglement entropy\nent_entropy, ent_spectrum = entanglement_entropy(ground_state)\n\nprintln(\"Entanglement Entropy: \", ent_entropy)\nprintln(\"Entanglement Spectrum: \", ent_spectrum)","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"The entanglement_entropy function calculates the entanglement entropy and spectrum of the given state. The entanglement entropy quantifies the amount of entanglement between the two halves of the system, while the entanglement spectrum provides more detailed information about the entanglement structure.","category":"page"},{"location":"advanced/#Conclusion-7","page":"Advanced Examples","title":"Conclusion","text":"","category":"section"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"This example demonstrates how to use the VQE algorithm to find the ground state of a quantum system and how to calculate the entanglement entropy of the resulting state. VQE is a powerful tool for studying quantum systems, especially when the exact diagonalization of the Hamiltonian is computationally infeasible. The entanglement entropy and spectrum provide valuable insights into the quantum correlations present in the system. The flexibility to use custom operations in the ansatz allows for the exploration of a wide range of quantum circuits.","category":"page"},{"location":"advanced/#19)-Measurement-induced-entanglement-transition-using-MPS","page":"Advanced Examples","title":"19) Measurement-induced entanglement transition using MPS","text":"","category":"section"},{"location":"advanced/#Overview-9","page":"Advanced Examples","title":"Overview","text":"","category":"section"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"In this section, we'll explore how measurements can induce entanglement in quantum systems using the Matrix Product State (MPS) representation. MPS is a powerful tool for efficiently simulating quantum systems, especially those with a large number of qubits. We'll create random quantum circuits with measurements and analyze how the entanglement entropy changes with the measurement probability.","category":"page"},{"location":"advanced/#Example:-Random-Quantum-Circuits-with-Measurements","page":"Advanced Examples","title":"Example: Random Quantum Circuits with Measurements","text":"","category":"section"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"First, we initialize the Hilbert space and MPS representation for a given number of qubits:","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"using BlueTangle\ninclude(pathof(BlueTangle) * \"../../extra/pyplot.jl\")","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"Next, we create a random quantum circuit with a specified depth and measurement probability:","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"N, M = init(6) # This creates qubit number N for Hilbert space and M for MPS sites.\n\ndepth = 3 #without measurements\nops = random_ops(N, depth; measure_prob=0.1, measure_basis=[\"MZ\"]) # Measurement probability is 0.1 and the basis is Z.\nplotq(ops)","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"(Image: )","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"We can apply these operations to both the Hilbert space state and the MPS state:","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"state = zero_state(N) # Create zero state (Hilbert)\npsi = zero_state(M) # Create zero state (MPS)\n\nfor o in ops # Apply operators\n    psi = apply(psi, o)\n    state = apply(state, o)\nend\n\nstate ≈ BlueTangle.to_state(psi) # Convert MPS to state and check if they are equal","category":"page"},{"location":"advanced/#Measurement-Induced-Entanglement-Transition","page":"Advanced Examples","title":"Measurement Induced Entanglement Transition","text":"","category":"section"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"Now, let's create a circuit and check how measurement induced entanglement transition exists:","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"dict_S = Dict() # We save results here\ndepth = 30\nmaxdim = 40 # This sets the maximum bond dimension\nmp_list = 0.1:0.1:1.0 # This is the measurement probability range\n\nfor qubits in [30, 40]\n    N, M = init(qubits) # This creates N for Hilbert space and M for MPS sites. Note the large number of qubits, which is feasible thanks to the MPS representation.\n    \n    for mp in mp_list # Run over different measurement probabilities\n        S_list = []\n        \n        for experiment in 1:50 # Number of realisations\n            ops = random_ops(N, depth; measure_prob=mp, measure_basis=[\"MZ\"])\n            psi = zero_state(M)\n            \n            for o in ops\n                psi = apply(o, psi; maxdim=maxdim)\n            end\n            \n            push!(S_list, entanglement_entropy(psi)) # Calculate entanglement entropy\n        end\n        \n        dict_S[N, mp] = S_list\n    end\nend","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"Finally, we can plot the average entanglement entropy as a function of the measurement probability for different system sizes:","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"fig = figure()\n\nN=30;plot(mp_list,[mean(dict_S[N,mp]) for mp=mp_list], label=\"N=$(N)\",marker=\"s\",ls=\"none\")\nN=40;plot(mp_list,[mean(dict_S[N,mp]) for mp=mp_list],label=\"N=$(N)\",marker=\"p\",ls=\"none\")\n\nxlabel(\"measurement probability\")\nylabel(\"entanglement entropy\")\nlegend()\n\nfig","category":"page"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"(Image: )","category":"page"},{"location":"advanced/#Conclusion-8","page":"Advanced Examples","title":"Conclusion","text":"","category":"section"},{"location":"advanced/","page":"Advanced Examples","title":"Advanced Examples","text":"This example demonstrates how measurement induced entanglement transition can be studied using the MPS representation. By creating random quantum circuits with measurements and varying the measurement probability, we can analyze how the entanglement entropy changes. The MPS representation allows us to efficiently simulate quantum systems with a large number of qubits, which would be computationally intractable using the full Hilbert space representation. This technique can be used to study various quantum phenomena and to understand the role of measurements in quantum systems.","category":"page"},{"location":"#BlueTangle.jl-Documentation","page":"Home","title":"BlueTangle.jl Documentation","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to BlueTangle.jl, a noisy quantum circuit simulator in Julia. This package is made for today's quantum computing needs and challenges. BlueTangle.jl is more than just a simulator. It's a complete toolkit for working with Noisy Intermediate-Scale Quantum (NISQ) devices.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Key Features of BlueTangle.jl:","category":"page"},{"location":"","page":"Home","title":"Home","text":"User-Friendly and Clean Code Structure: Thanks to Julia's multiple dispatch, BlueTangle.jl provides a straightforward and clean function namespace that's easy to use and understand.\nMid-Circuit Measurements: Incorporates crucial conditional mid-circuit measurements. This feature is valuable for studying measured-based phenomena like entanglement phase transitions. It also allows for probing exotic phenomena such as the Quantum Zeno effect, where frequent measurements can effectively slow down the evolution of a quantum system.\nQuantum Noise Channels: Offers predefined and customizable noise channels using Kraus operators, enhancing the simulation's resemblance to real quantum environments.\nError Mitigation Techniques: Features error mitigation methods, including Pauli twirling, zero-noise extrapolation and measurement error mitigation, which are crucial for reducing noise in quantum computations. These techniques can be easily applied using a single function.\nFlexible Quantum State Representations: Offers the flexibility to perform quantum simulations using various mathematical representations. You can seamlessly switch between state vector, density matrix, and Matrix Product State (powered by ITensor) backgrounds while using the same high-level functions for circuit creation, measurement, and analysis. This feature allows you to choose the most suitable representation for your specific problem, considering factors such as system size, entanglement, and computational resources.\nAutomated Trotterized Hamiltonians: Simplifies the creation of trotterized Hamiltonians by allowing users to input a string of operators, streamlining the process of simulating quantum systems.\nAutomated Variational Algorithms: Offers a streamlined and user-friendly implementation of the Variational Quantum Eigensolver (VQE) algorithm. With just a few lines of code, users can easily set up and run VQE simulations to find the ground state energy of a given Hamiltonian. The package takes care of constructing the variational quantum circuit, optimizing the parameters, and returning the final results, making it a convenient tool for exploring quantum chemistry and optimization problems.\nStabilizer Codes: Supports the creation and manipulation of quantum stabilizer error-correcting codes. This feature allows users to define stabilizer codes using a set of stabilizers and logical operators. The package provides functions for encoding, decoding, applying logical operations, making it a powerful tool for practical aspects of fault-tolerant quantum computing research.\nQuantum Information Toolkit: This toolkit enables measuring quantum entanglement, calculating partial traces, and assessing the gaussianity of states. Additionally, it features a function for calculating high-order moments, providing a unique perspective on phase transitions. It also includes simple implementation of phase estimation and the ability to conduct classical shadow experiments, making it a versatile resource for quantum computing research.\nSpeed and Efficiency: Optimized for high performance, harnessing Julia's advanced JIT compilation capabilities. This ensures fast and efficient simulations, despite being packed with a multitude of features. Its design is ideal for the iterative testing and development of complex quantum circuits, providing a balance between comprehensive functionality and swift execution.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Future Developments: This package has plans to:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Develop the circuit optimization feature using ZX calculus, aiming to reduce resource requirements.\nIntegrate quantum error correction codes (including stabilizer formalism), leveraging the package's flexible design for mid-circuit measurements. This enhancement will enable improved testing and development of error correction codes within the platform.","category":"page"},{"location":"","page":"Home","title":"Home","text":"BlueTangle.jl is designed for a diverse audience, from researchers to quantum computing enthusiasts. It stands as a robust platform for experimentation in the quantum computing landscape.","category":"page"},{"location":"#Notice:-Package-Under-Development","page":"Home","title":"Notice: Package Under Development","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Please be aware that this package is currently under active development and is in its alpha version. This means that the features are still being finalised, and the functionality is subject to change. Users may encounter bugs or incomplete features.","category":"page"},{"location":"#About-the-Developer","page":"Home","title":"About the Developer","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Aydin Deger, a Research Fellow in Quantum Computing Theory at University College London, is the sole developer of the BlueTangle.jl. With a deep interest in theoretical physics and quantum computing, Aydin aims to bridge complex quantum concepts with practical computing applications through this package. BlueTangle.jl embodies his vision of making quantum computing more accessible and comprehensible to a diverse audience, from researchers to enthusiasts.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For further information or to explore more about Aydin's work, please visit deger.xyz.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Installing BlueTangle is straightforward. You can install it through the Julia REPL using the following command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(url=\"https://github.com/aydindeger/BlueTangle.jl\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Alternatively, type ] add https://github.com/aydindeger/BlueTangle.jl directly in the Julia REPL.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To load the package in your Julia environment, use:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using BlueTangle","category":"page"},{"location":"","page":"Home","title":"Home","text":"For direct installation from the source, such as in a Jupyter notebook located at the root folder of the package, use:","category":"page"},{"location":"","page":"Home","title":"Home","text":"cd(@__DIR__)\npush!(LOAD_PATH, \"src\")\nusing BlueTangle","category":"page"},{"location":"#FAQ","page":"Home","title":"FAQ","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Q: What's the inspiration behind the name 'BlueTangle'?","category":"page"},{"location":"","page":"Home","title":"Home","text":"A: The name 'BlueTangle' merges quantum computing ideas with cultural elements. The 'tangle' part reflects the complex correlations in quantum systems, while 'Blue' is inspired by a Bob Dylan song, 'Tangled Up in Blue', representing complex narratives similar to those in quantum computing.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Q: Who designed the logo for this package?","category":"page"},{"location":"","page":"Home","title":"Home","text":"A: The logo was created using DALL-E.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Q: How can I cite BlueTangle.jl in my research work?","category":"page"},{"location":"","page":"Home","title":"Home","text":"A: For citation in research work, please use the following reference:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Aydin Deger, \"BlueTangle.jl: A Noisy and Dynamic Quantum Circuit Simulator\", https://github.com/aydindeger/BlueTangle/ (2024).","category":"page"}]
}
