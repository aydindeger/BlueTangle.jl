<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Examples · BlueTangle.jl</title><meta name="title" content="Examples · BlueTangle.jl"/><meta property="og:title" content="Examples · BlueTangle.jl"/><meta property="twitter:title" content="Examples · BlueTangle.jl"/><meta name="description" content="Documentation for BlueTangle.jl."/><meta property="og:description" content="Documentation for BlueTangle.jl."/><meta property="twitter:description" content="Documentation for BlueTangle.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="BlueTangle.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">BlueTangle.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Examples</a><ul class="internal"><li><a class="tocitem" href="#1)-GHZ-Circuit"><span>1) GHZ Circuit</span></a></li><li><a class="tocitem" href="#2)-Measurement-and-Correlations"><span>2) Measurement and Correlations</span></a></li><li><a class="tocitem" href="#3)-Plot-Circuits-and-Measurements"><span>3) Plot Circuits and Measurements</span></a></li><li><a class="tocitem" href="#4)-Noise-Models-and-Circuits"><span>4) Noise Models and Circuits</span></a></li><li><a class="tocitem" href="#5)-Custom-Noise-Models-and-Gates"><span>5) Custom Noise Models and Gates</span></a></li><li><a class="tocitem" href="#6)-Conditional-Mid-Measurements"><span>6) Conditional Mid-Measurements</span></a></li><li><a class="tocitem" href="#7)-Reset-Operation-on-a-Qubit"><span>7) Reset Operation on a Qubit</span></a></li><li><a class="tocitem" href="#8)-Random-Quantum-Circuits"><span>8) Random Quantum Circuits</span></a></li></ul></li><li><a class="tocitem" href="../advanced/">Advanced Examples</a></li><li><a class="tocitem" href="../functions/">Functions</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Examples</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Examples</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/aydindeger/BlueTangle.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/aydindeger/BlueTangle.jl/blob/main/docs/src/examples.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h1><h2 id="1)-GHZ-Circuit"><a class="docs-heading-anchor" href="#1)-GHZ-Circuit">1) GHZ Circuit</a><a id="1)-GHZ-Circuit-1"></a><a class="docs-heading-anchor-permalink" href="#1)-GHZ-Circuit" title="Permalink"></a></h2><h3 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h3><p>This example demonstrates the use of the package for creating a Greenberger–Horne–Zeilinger (GHZ) state circuit.</p><h3 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h3><h4 id="Step-1:-Collect-Quantum-Operations"><a class="docs-heading-anchor" href="#Step-1:-Collect-Quantum-Operations">Step 1: Collect Quantum Operations</a><a id="Step-1:-Collect-Quantum-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Step-1:-Collect-Quantum-Operations" title="Permalink"></a></h4><p>Define quantum operations to prepare the GHZ state.</p><pre><code class="language-julia hljs">using BlueTangle

# Quantum gates
hadamard = Op(&quot;H&quot;, 1) # Hadamard gate on the first qubit
cnot1 = Op(&quot;CNOT&quot;, 1, 2) # CNOT gate between first and second qubits
cnot2 = Op(&quot;CNOT&quot;, 2, 3) # CNOT gate between second and third qubits

ops = [hadamard, cnot1, cnot2] # Collect operators</code></pre><h4 id="Step-2:-Create-Quantum-Circuit"><a class="docs-heading-anchor" href="#Step-2:-Create-Quantum-Circuit">Step 2: Create Quantum Circuit</a><a id="Step-2:-Create-Quantum-Circuit-1"></a><a class="docs-heading-anchor-permalink" href="#Step-2:-Create-Quantum-Circuit" title="Permalink"></a></h4><p>Next, we <a href="../functions/#BlueTangle.compile"><code>compile</code></a> these operations into a quantum circuit and check its properties.</p><pre><code class="language-julia hljs">circuit = compile(ops) # Create a quantum circuit
println(&quot;Circuit stats:&quot;, circuit.stats)</code></pre><h2 id="2)-Measurement-and-Correlations"><a class="docs-heading-anchor" href="#2)-Measurement-and-Correlations">2) Measurement and Correlations</a><a id="2)-Measurement-and-Correlations-1"></a><a class="docs-heading-anchor-permalink" href="#2)-Measurement-and-Correlations" title="Permalink"></a></h2><h3 id="Overview-2"><a class="docs-heading-anchor" href="#Overview-2">Overview</a><a class="docs-heading-anchor-permalink" href="#Overview-2" title="Permalink"></a></h3><p>This section explores two methods for obtaining measurement data and correlations from a quantum circuit, showcasing two distinct approaches:</p><ol><li><strong>Sampling Measurement</strong>: This approach involves approximating values by taking multiple samples from the quantum circuit.</li><li><strong>Exact Calculation using Density Matrix</strong>: This method uses the density matrix of the circuit for precise calculations.</li></ol><h3 id="Measurement-Sampling-Approach"><a class="docs-heading-anchor" href="#Measurement-Sampling-Approach">Measurement - Sampling Approach</a><a id="Measurement-Sampling-Approach-1"></a><a class="docs-heading-anchor-permalink" href="#Measurement-Sampling-Approach" title="Permalink"></a></h3><p>Perform measurements through sampling and analyse the results. For more details on this function, see <a href="../functions/#BlueTangle.measure"><code>measure</code></a>.</p><pre><code class="language-julia hljs">shots = 1000
measurement1 = measure(circuit, shots) # Sample the circuit

println(&quot;Attributes of the measurement object&quot;,fields(measurement1))

# Output measurement details
println(&quot;Expectation values:&quot;, measurement1.expect)
println(&quot;Total magnetization moments:&quot;, measurement1.mag_moments)

# Calculate correlations: ⟨Z₁Z₂⟩
correlations1 = correlation(measurement1, [1, 2])
println(&quot;Correlations:&quot;, correlations1)</code></pre><h3 id="Measurement-Exact-Approach-using-Density-Matrix"><a class="docs-heading-anchor" href="#Measurement-Exact-Approach-using-Density-Matrix">Measurement - Exact Approach using Density Matrix</a><a id="Measurement-Exact-Approach-using-Density-Matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Measurement-Exact-Approach-using-Density-Matrix" title="Permalink"></a></h3><p>Alternatively, we can use the density matrix for exact calculations. Similar one can use state vectors as well, see <a href="../functions/#BlueTangle.to_state"><code>to_state</code></a>.</p><pre><code class="language-julia hljs">density_matrix = to_rho(circuit)

# Calculate exact expectation values and correlations
expect2 = expect(density_matrix, &quot;Z&quot;)
correlations2 = correlation(density_matrix, &quot;Z,Z&quot;, [1, 2]) # Calculate correlations: ⟨Z₁Z₂⟩

println(&quot;Exact expectation values:&quot;, expect2)
println(&quot;Exact correlations:&quot;, correlations2)</code></pre><p><strong>Calculations in Different Bases</strong></p><p>With the exact density matrix, we can explore correlations in different bases, unlike the sampling measurement.</p><pre><code class="language-julia hljs">expect3 = expect(density_matrix, &quot;Y&quot;)
correlations3 = correlation(density_matrix, &quot;Z,X&quot;, [1, 3])

println(&quot;Expectation values &lt;Y&gt;:&quot;, expect3)
println(&quot;Correlations &lt;Z₁X₃&gt;:&quot;, correlations3)</code></pre><p>This example highlights the flexibility and power of the package in quantum circuit analysis and simulation.</p><h2 id="3)-Plot-Circuits-and-Measurements"><a class="docs-heading-anchor" href="#3)-Plot-Circuits-and-Measurements">3) Plot Circuits and Measurements</a><a id="3)-Plot-Circuits-and-Measurements-1"></a><a class="docs-heading-anchor-permalink" href="#3)-Plot-Circuits-and-Measurements" title="Permalink"></a></h2><h3 id="Overview-3"><a class="docs-heading-anchor" href="#Overview-3">Overview</a><a class="docs-heading-anchor-permalink" href="#Overview-3" title="Permalink"></a></h3><p>The <code>plotq</code> function is designed to create visual representations of quantum circuits, while the <code>plotq</code> function displays the results of quantum measurements. Both of these functions are dependent on the <code>PyPlot</code> package.</p><h3 id="Example-2"><a class="docs-heading-anchor" href="#Example-2">Example</a><a class="docs-heading-anchor-permalink" href="#Example-2" title="Permalink"></a></h3><h4 id="Step-1:-Define-and-Compile-a-Quantum-Circuit"><a class="docs-heading-anchor" href="#Step-1:-Define-and-Compile-a-Quantum-Circuit">Step 1: Define and Compile a Quantum Circuit</a><a id="Step-1:-Define-and-Compile-a-Quantum-Circuit-1"></a><a class="docs-heading-anchor-permalink" href="#Step-1:-Define-and-Compile-a-Quantum-Circuit" title="Permalink"></a></h4><p>Create a simple quantum circuit for demonstration.</p><pre><code class="language-julia hljs">using BlueTangle
include(pathof(BlueTangle) * &quot;../../extra/pyplot.jl&quot;)</code></pre><pre><code class="language-julia hljs"># Quantum gates for a basic circuit
hadamard = Op(&quot;H&quot;, 1)
cnot12 = Op(&quot;CNOT&quot;, 1, 2)
cnot23 = Op(&quot;CNOT&quot;, 2, 3)

# Compile the circuit
circuit = compile([hadamard, cnot12, cnot23])</code></pre><h4 id="Step-2:-Visualize-the-Circuit"><a class="docs-heading-anchor" href="#Step-2:-Visualize-the-Circuit">Step 2: Visualize the Circuit</a><a id="Step-2:-Visualize-the-Circuit-1"></a><a class="docs-heading-anchor-permalink" href="#Step-2:-Visualize-the-Circuit" title="Permalink"></a></h4><p>Use <code>plotq</code> to visualize the circuit structure.</p><pre><code class="language-julia hljs">plotq(circuit)</code></pre><p><img src="../assets/figs/circuit.png" alt/></p><h4 id="Step-3:-Perform-Measurements-and-Analyze-Results"><a class="docs-heading-anchor" href="#Step-3:-Perform-Measurements-and-Analyze-Results">Step 3: Perform Measurements and Analyze Results</a><a id="Step-3:-Perform-Measurements-and-Analyze-Results-1"></a><a class="docs-heading-anchor-permalink" href="#Step-3:-Perform-Measurements-and-Analyze-Results" title="Permalink"></a></h4><p>Conduct measurements on the circuit and examine the outcomes.</p><pre><code class="language-julia hljs">measurement = measure(circuit, 1000) # Sample the circuit 1000 times</code></pre><h4 id="Step-4:-Plot-Measurement-Results"><a class="docs-heading-anchor" href="#Step-4:-Plot-Measurement-Results">Step 4: Plot Measurement Results</a><a id="Step-4:-Plot-Measurement-Results-1"></a><a class="docs-heading-anchor-permalink" href="#Step-4:-Plot-Measurement-Results" title="Permalink"></a></h4><p>Visualize the measurement data using <code>plotq</code>.</p><pre><code class="language-julia hljs">plotq(measurement)</code></pre><p><img src="../assets/figs/measure.png" alt/></p><h3 id="Troubleshooting-Plotting-Issues"><a class="docs-heading-anchor" href="#Troubleshooting-Plotting-Issues">Troubleshooting Plotting Issues</a><a id="Troubleshooting-Plotting-Issues-1"></a><a class="docs-heading-anchor-permalink" href="#Troubleshooting-Plotting-Issues" title="Permalink"></a></h3><p>If you encounter problems with plotting, please follow these steps:</p><p><strong>Install PyPlot in Julia</strong>: Add the <code>PyPlot</code> package to your Julia environment. This package provides an interface to the <code>matplotlib</code> library in Python. You can install it using the Julia package manager:</p><pre><code class="language-julia hljs">import Pkg
Pkg.add(&quot;PyPlot&quot;)</code></pre><p><strong>Install Python Matplotlib</strong>: Ensure that <code>matplotlib</code> is installed in your Python environment. This is a prerequisite for <code>PyPlot</code> as it relies on Python&#39;s <code>matplotlib</code> for plotting. You can install <code>matplotlib</code> using <code>pip</code>:</p><pre><code class="language-bash hljs">pip3 install matplotlib</code></pre><p>For detailed documentation and additional information, refer to the <a href="https://github.com/JuliaPy/PyPlot.jl"><code>PyPlot</code> GitHub page</a>.</p><h2 id="4)-Noise-Models-and-Circuits"><a class="docs-heading-anchor" href="#4)-Noise-Models-and-Circuits">4) Noise Models and Circuits</a><a id="4)-Noise-Models-and-Circuits-1"></a><a class="docs-heading-anchor-permalink" href="#4)-Noise-Models-and-Circuits" title="Permalink"></a></h2><h3 id="Overview-4"><a class="docs-heading-anchor" href="#Overview-4">Overview</a><a class="docs-heading-anchor-permalink" href="#Overview-4" title="Permalink"></a></h3><p>This example shows how to create noisy quantum circuits using predefined quantum noise models. The package offers precise control over each quantum operation, allowing for different noise models for individual operations or overall models for single and two-qubit operations.</p><h3 id="Predefined-Noise-Models"><a class="docs-heading-anchor" href="#Predefined-Noise-Models">Predefined Noise Models</a><a id="Predefined-Noise-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Predefined-Noise-Models" title="Permalink"></a></h3><ul><li><code>amplitude_damping</code>: Simulates energy loss in a quantum system. Parameter <code>γ</code> (given by <code>p</code>) indicates the excitation loss probability.</li><li><code>phase_damping</code>: Loss of quantum information without energy loss. Parameter <code>γ</code> quantifies the likelihood of a phase shift.</li><li><code>phase_flip</code>: Introduces phase errors (Z error) with probability <code>p</code>.</li><li><code>bit_flip</code>: Causes state flips (X error) with probability <code>p</code>.</li><li><code>bit_phase_flip</code>: Combines bit and phase flips, applying Y error with probability <code>p</code>.</li><li><code>depolarizing</code>: General error model where any Pauli operation (X, Y, Z) can occur with equal probability. Parameter <code>p</code> is the overall error probability.</li><li><code>rot_X</code>, <code>rot_Y</code>, <code>rot_Z</code>, <code>rot_P</code>: Coherent errors (incorrect rotations) around respective axes. Parameter <code>p</code> specifies rotation error magnitude.</li></ul><h3 id="Implementing-Noise-in-Circuits"><a class="docs-heading-anchor" href="#Implementing-Noise-in-Circuits">Implementing Noise in Circuits</a><a id="Implementing-Noise-in-Circuits-1"></a><a class="docs-heading-anchor-permalink" href="#Implementing-Noise-in-Circuits" title="Permalink"></a></h3><p>The code below demonstrates how to create a noise model for single qubit gates. The second parameter defines either the amplitude or the probability of the noise model, depending on the selected model. For example:</p><pre><code class="language-julia hljs">noise_model1 = Noise1(&quot;bit_flip&quot;, 0.001)</code></pre><p>In this instance, <a href="../functions/#BlueTangle.Noise1"><code>Noise1</code></a> constructs a noise model for single qubit operations, specifically a bit flip error, with a probability of 0.001 (or 0.1%).</p><p>Similarly, a noise model for two-qubit operations can be created:</p><pre><code class="language-julia hljs">noise_model2 = Noise2(&quot;depolarizing&quot;, 0.01)</code></pre><p>Here, <a href="../functions/#BlueTangle.Noise2"><code>Noise2</code></a> is applied to create a depolarizing channel noise model for two-qubit gates, with an error probability of 0.01 (or 1%).</p><p>We can now create the <code>NoiseModel</code> as following</p><pre><code class="language-julia hljs">nm=NoiseModel(n1,n2)

#Alternatively following constructions give the same result

nm=NoiseModel(&quot;bit_flip&quot;, 0.001,&quot;depolarizing&quot;, 0.01)
nm=NoiseModel([&quot;bit_flip&quot;, 0.001],[&quot;depolarizing&quot;, 0.01])</code></pre><p>Next, we will illustrate incorporating these noise models into a quantum circuit.</p><pre><code class="language-julia hljs">ops = [Op(&quot;H&quot;, 1), Op(&quot;CNOT&quot;, 1, 2), Op(&quot;CNOT&quot;, 2, 3)]
noisy_circuit = compile(ops, Options(noise=nm))</code></pre><h2 id="5)-Custom-Noise-Models-and-Gates"><a class="docs-heading-anchor" href="#5)-Custom-Noise-Models-and-Gates">5) Custom Noise Models and Gates</a><a id="5)-Custom-Noise-Models-and-Gates-1"></a><a class="docs-heading-anchor-permalink" href="#5)-Custom-Noise-Models-and-Gates" title="Permalink"></a></h2><h3 id="Overview-and-Examples"><a class="docs-heading-anchor" href="#Overview-and-Examples">Overview and Examples</a><a id="Overview-and-Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Overview-and-Examples" title="Permalink"></a></h3><ul><li><p>Predefined constant gates, such as <code>gate[:X]</code>, <code>gate[:CNOT]</code> or <code>gate.T</code>, can be easily accessed. For more details, see <a href="../functions/#BlueTangle.gate"><code>gate</code></a>.</p></li><li><p>Phase (<code>P</code>) and rotation gates (<code>RX</code>, <code>RY</code>, <code>RZ</code>) can be accessed through <code>gates1(&quot;RX(.3)&quot;)</code>, or the controlled phase gate via <code>gates(&quot;CP(.3)&quot;)</code>. Refer to <code>gates</code> and <code>gates</code> for more information. Additionally, all single qubit rotations can be created using <code>U</code> gates with Euler angles, as detailed in <code>_P</code>, <code>_U2</code>, and <code>_U3</code>.</p></li><li><p>For custom defined gates, you can construct your own unitary matrix and create an <code>Op</code> object using the following constructor: <code>Op(&quot;name_of_my_gate&quot;, matrix, qubit)</code>.</p></li><li><p>To create a custom noise model, define your own Kraus operators for a single qubit model using <code>QuantumChannel(1, &quot;name_of_model&quot;, 0, vector_of_kraus_matrices)</code> or for a two-qubit model with <code>QuantumChannel(2, &quot;name_of_model&quot;, 0, vector_of_kraus_matrices)</code>. It&#39;s important to first check if your Kraus operators satisfy the trace-preserving condition using the <a href="../functions/#BlueTangle.is_valid_quantum_channel"><code>is_valid_quantum_channel</code></a> function. Alternatively, you can use the simpler constructor <code>custom_noise(q, name_of_model, vector_of_kraus_matrices)</code>, where <code>q</code> is either 1 or 2 for single and two qubit gates, respectively.</p></li></ul><h2 id="6)-Conditional-Mid-Measurements"><a class="docs-heading-anchor" href="#6)-Conditional-Mid-Measurements">6) Conditional Mid-Measurements</a><a id="6)-Conditional-Mid-Measurements-1"></a><a class="docs-heading-anchor-permalink" href="#6)-Conditional-Mid-Measurements" title="Permalink"></a></h2><h3 id="Overview-5"><a class="docs-heading-anchor" href="#Overview-5">Overview</a><a class="docs-heading-anchor-permalink" href="#Overview-5" title="Permalink"></a></h3><p>This section introduces the concept and implementation of conditional mid-measurements in quantum circuits. Mid-measurements are powerful tools that allow for conditional execution of quantum operations based on the results of measurements made during the circuit&#39;s execution. The application of the Born rule in these measurements adds a probabilistic dimension to the circuit&#39;s behaviour.</p><h3 id="Conditional-Mid-Measurements-with-ifOp"><a class="docs-heading-anchor" href="#Conditional-Mid-Measurements-with-ifOp">Conditional Mid-Measurements with <code>ifOp</code></a><a id="Conditional-Mid-Measurements-with-ifOp-1"></a><a class="docs-heading-anchor-permalink" href="#Conditional-Mid-Measurements-with-ifOp" title="Permalink"></a></h3><p>The <a href="../functions/#BlueTangle.ifOp"><code>ifOp</code></a> function enables conditional mid-measurements. For instance, consider a mid-measurement in the X basis for the first qubit, followed by conditional operations:</p><pre><code class="language-julia hljs">mid_measurement = ifOp(&quot;MX&quot;, 1, &quot;Z&quot;, &quot;H&quot;)
ops = [Op(&quot;X&quot;, 1), mid_measurement, Op(&quot;CNOT&quot;, 1, 2), Op(&quot;CNOT&quot;, 2, 3)]</code></pre><p>Let&#39;s break down the example to understand it better:</p><p><strong>Function Overview: <code>ifOp</code></strong></p><ul><li>The <code>ifOp</code> function is used to apply different quantum operations conditionally, depending on the outcome of a mid-circuit measurement.</li></ul><p><strong>Setting Up a Conditional Operation:</strong></p><ul><li>In the example, <code>mid_measurement = ifOp(&quot;MX&quot;, 1, &quot;Z&quot;, &quot;H&quot;)</code> defines a conditional operation.</li><li><code>&quot;MX&quot;</code> specifies the measurement basis (here, the X basis).</li><li>The number <code>1</code> indicates that the measurement is performed on the first qubit.</li><li><code>Z</code> (Z gate) and <code>H</code> (Hadamard gate) are the conditional operations.</li><li>The function is set up so that if the measurement result of the first qubit in the X basis is <code>0</code>, the Z gate (<code>Z</code>) is applied. If the result is <code>1</code>, the Hadamard gate (<code>H</code>) is applied.</li></ul><p><strong>Sequence of Operations:</strong></p><ul><li>The operations sequence is given by <code>ops = [Op(&quot;X&quot;, 1), mid_measurement, Op(&quot;CNOT&quot;, 1, 2), Op(&quot;CNOT&quot;, 2, 3)]</code>.</li><li><code>Op(&quot;X&quot;, 1)</code> applies an X gate to the first qubit.</li><li><code>mid_measurement</code> is then executed, which is the conditional operation defined above.</li><li>Following the conditional operation, two CNOT gates are applied: <code>Op(&quot;CNOT&quot;, 1, 2)</code> entangles the first and second qubits, and <code>Op(&quot;CNOT&quot;, 2, 3)</code> entangles the second and third qubits.</li></ul><p><strong>Outcome:</strong></p><ul><li>The outcome of <code>mid_measurement</code> directly influences the state of the circuit after the measurement.</li><li>Depending on the measurement result, the circuit will have either undergone a Hadamard transformation (if the result was <code>0</code>) or a Z transformation (if the result was <code>1</code>) on the first qubit before proceeding to the subsequent CNOT gates.</li></ul><h3 id="Workout-Example"><a class="docs-heading-anchor" href="#Workout-Example">Workout Example</a><a id="Workout-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Workout-Example" title="Permalink"></a></h3><ol><li><strong>Starting State</strong>: The initial state is |000⟩.</li><li><strong>Application of X Gate</strong>: Applying the X gate to the first qubit changes the state to |100⟩.</li><li><strong>Conditional Mid-Measurement</strong>: When the first qubit is measured in the X basis, the outcome is determined by the Born rule from a superposition state of |000⟩ and -|100⟩. Based on the measurement:<ul><li>If the result is 0, apply a Z gate. The state becomes superposition state of |000⟩ and -|100⟩.</li><li>If the result is 1, apply a H gate. The state becomes -|100⟩.</li></ul></li><li><strong>Subsequent CNOT Operations</strong>: Applying the first CNOT gate entangles the first and second qubits, and the second CNOT gate entangles the second and third qubits. This results in either the state |111⟩ or (|000⟩ - |111⟩)/√2, each with a 50% probability due to the superposition created by the mid-measurement.</li></ol><p>Let&#39;s test this using two different methods.</p><h3 id="Method-1-Simulation-with-a-Circuit"><a class="docs-heading-anchor" href="#Method-1-Simulation-with-a-Circuit">Method 1 - Simulation with a Circuit</a><a id="Method-1-Simulation-with-a-Circuit-1"></a><a class="docs-heading-anchor-permalink" href="#Method-1-Simulation-with-a-Circuit" title="Permalink"></a></h3><p>To test the operations, we first compile the circuit and then sample it to obtain a measurement object. The <a href="../functions/#BlueTangle.compile"><code>compile</code></a> function is used to assemble the circuit, and <a href="../functions/#BlueTangle.measure"><code>measure</code></a> is employed to simulate the circuit&#39;s execution and generate a <a href="../functions/#BlueTangle.Measurement"><code>Measurement</code></a> object.</p><pre><code class="language-julia hljs">circuit = compile(ops)
measurement = measure(circuit,1000)</code></pre><p>After obtaining the measurement object, we can visualise the results:</p><pre><code class="language-julia hljs">plotq(measurement)</code></pre><p><img src="../assets/figs/measure_mid.png" alt/></p><p>The measurement results show that half of the time, the state is on <code>7=|111⟩</code>, and the other half, it is on the GHZ state (<code>7=|111⟩</code> and <code>0=|000⟩</code>).</p><h3 id="Method-2-Manual-Simulation-with-a-Quantum-Simulator"><a class="docs-heading-anchor" href="#Method-2-Manual-Simulation-with-a-Quantum-Simulator">Method 2 - Manual Simulation with a Quantum Simulator</a><a id="Method-2-Manual-Simulation-with-a-Quantum-Simulator-1"></a><a class="docs-heading-anchor-permalink" href="#Method-2-Manual-Simulation-with-a-Quantum-Simulator" title="Permalink"></a></h3><p>Alternatively, we can manually simulate the same process using a quantum simulator. This approach provides a more hands-on understanding of how each operation affects the state of the quantum system:</p><pre><code class="language-julia hljs">state = zero_state(3) # Initial state for N=3
state=apply(state, Op(&quot;X&quot;, 1)) # Apply X on qubit 1
state=apply(state, ifOp(&quot;MX&quot;, 1, &quot;Z&quot;, &quot;H&quot;)) # Measure qubit 1 in X basis. Apply Z if result is 0, H if 1.
state=apply(state, Op(&quot;CNOT&quot;, 1, 2)) # Apply CNOT on qubit 1 and 2
state=apply(state, Op(&quot;CNOT&quot;, 2, 3)) # Apply CNOT on qubit 2 and 3
state # Final result: either GHZ state or |111&gt; state.</code></pre><p>This manual simulation helps illustrate the probabilistic nature of quantum circuits involving mid-measurements and demonstrates the creation of complex quantum states, such as the GHZ state.</p><h2 id="7)-Reset-Operation-on-a-Qubit"><a class="docs-heading-anchor" href="#7)-Reset-Operation-on-a-Qubit">7) Reset Operation on a Qubit</a><a id="7)-Reset-Operation-on-a-Qubit-1"></a><a class="docs-heading-anchor-permalink" href="#7)-Reset-Operation-on-a-Qubit" title="Permalink"></a></h2><h3 id="Overview-6"><a class="docs-heading-anchor" href="#Overview-6">Overview</a><a class="docs-heading-anchor-permalink" href="#Overview-6" title="Permalink"></a></h3><p>In this example, we demonstrate how to implement a reset operation on a qubit. This operation involves measuring a qubit and, depending on the outcome, applying a corrective operation. Specifically, if the qubit is measured and found to be in the |1⟩ state, an X gate is applied to bring it back to the |0⟩ state. We&#39;ll illustrate this concept by creating a Bell state and then resetting the first qubit.</p><h3 id="Example-1:-Reset-via-measurement"><a class="docs-heading-anchor" href="#Example-1:-Reset-via-measurement">Example 1: Reset via measurement</a><a id="Example-1:-Reset-via-measurement-1"></a><a class="docs-heading-anchor-permalink" href="#Example-1:-Reset-via-measurement" title="Permalink"></a></h3><p>First, we start by preparing a Bell state. A Bell state is a maximally entangled quantum state of two qubits. It represents a perfect example of quantum entanglement and is foundational in quantum computing and quantum information theory.</p><pre><code class="language-julia hljs"># Number of qubits
N = 2

# Initialising the state vector
state = zero_state(N)

# Applying Hadamard gate to the first qubit
state=apply(state, Op(&quot;H&quot;, 1))

# Applying CNOT gate with the first qubit as control and the second as target
state=apply(state, Op(&quot;CX&quot;, 1, 2))

# Show the state of the qubits
display(state)</code></pre><p>At this point, the system is in a Bell state, which is an equal superposition of |00⟩ and |11⟩ states. You can see this with the following code</p><pre><code class="language-julia hljs">fock_basis_create(N)</code></pre><p>Now, we&#39;ll implement the reset operation on the first qubit. This operation involves measuring the first qubit. If the measurement result is |1⟩, we apply the X gate to flip it back to |0⟩. </p><pre><code class="language-julia hljs"># Reset operation on the first qubit
op = Op(&quot;RES&quot;, 1)
apply(state, op)</code></pre><h3 id="Understanding-the-Outcome"><a class="docs-heading-anchor" href="#Understanding-the-Outcome">Understanding the Outcome</a><a id="Understanding-the-Outcome-1"></a><a class="docs-heading-anchor-permalink" href="#Understanding-the-Outcome" title="Permalink"></a></h3><p>After the reset operation, the state of the qubits can be either |00⟩ or |01⟩. The outcome depends on the state of the first qubit at the time of measurement. If the first qubit was in the |0⟩ state (which happens with a 50% probability due to the Bell state&#39;s nature), the reset operation does nothing. However, if the first qubit was in the |1⟩ state (again, a 50% chance), the X gate flips it to |0⟩. </p><p>Since the second qubit is entangled with the first, its state is correlated. Therefore, measuring the first qubit and applying the reset operation affects the overall state of the two-qubit system. </p><h2 id="8)-Random-Quantum-Circuits"><a class="docs-heading-anchor" href="#8)-Random-Quantum-Circuits">8) Random Quantum Circuits</a><a id="8)-Random-Quantum-Circuits-1"></a><a class="docs-heading-anchor-permalink" href="#8)-Random-Quantum-Circuits" title="Permalink"></a></h2><h3 id="Overview-7"><a class="docs-heading-anchor" href="#Overview-7">Overview</a><a class="docs-heading-anchor-permalink" href="#Overview-7" title="Permalink"></a></h3><p>In this section, we explore the generation of random quantum circuits, a powerful tool for various quantum computing simulations. The circuits can consist of Clifford gates, a mix of Clifford and non-Clifford gates, and optional mid-circuit measurements in specified bases.</p><h3 id="Generating-Random-Clifford-Operations"><a class="docs-heading-anchor" href="#Generating-Random-Clifford-Operations">Generating Random Clifford Operations</a><a id="Generating-Random-Clifford-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Generating-Random-Clifford-Operations" title="Permalink"></a></h3><p>Define the number of qubits (N) and the length of the quantum circuit (len), then generate a random sequence of Clifford operations:</p><pre><code class="language-julia hljs">N = 3 # Number of qubits
len = 5 # Length of the quantum circuit
random_operations = random_clifford(N, len)</code></pre><h3 id="Generating-Mixed-Random-Operations"><a class="docs-heading-anchor" href="#Generating-Mixed-Random-Operations">Generating Mixed Random Operations</a><a id="Generating-Mixed-Random-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Generating-Mixed-Random-Operations" title="Permalink"></a></h3><p>For a more diverse circuit, generate a random sequence including both Clifford and non-Clifford operations. Note that following code will generate depth=len circuit.</p><pre><code class="language-julia hljs">random_operations = random_ops(N, len)</code></pre><h3 id="Including-Mid-Circuit-Measurements"><a class="docs-heading-anchor" href="#Including-Mid-Circuit-Measurements">Including Mid-Circuit Measurements</a><a id="Including-Mid-Circuit-Measurements-1"></a><a class="docs-heading-anchor-permalink" href="#Including-Mid-Circuit-Measurements" title="Permalink"></a></h3><p>The <code>random_clifford</code> function can also incorporate mid-circuit measurements. This is controlled by the <code>measure_prob</code> parameter, which dictates the probability of a measurement occurring after each gate, and the <code>measure_basis</code> parameter, specifying the measurement bases (e.g., &quot;MX&quot;, &quot;MY&quot;, &quot;MZ&quot;).</p><p>For instance, to create a random sequence of Clifford gates with a 20% chance of measurement in either the &quot;MX&quot; or &quot;MZ&quot; basis after each gate in a 5-qubit system:</p><pre><code class="language-julia hljs">ops = random_clifford(5, 20; measure_prob=0.2, measure_basis=[&quot;MX&quot;,&quot;MZ&quot;])
random_circuit = compile(ops)</code></pre><p>This function will randomly select operations from a set of Clifford gates or measurements, applying them to either single or adjacent qubits. </p><h3 id="Visualizing-the-Random-Circuit"><a class="docs-heading-anchor" href="#Visualizing-the-Random-Circuit">Visualizing the Random Circuit</a><a id="Visualizing-the-Random-Circuit-1"></a><a class="docs-heading-anchor-permalink" href="#Visualizing-the-Random-Circuit" title="Permalink"></a></h3><p>After generating the random operations, you can visualize the circuit to better understand its structure:</p><pre><code class="language-julia hljs">plotq(random_circuit)</code></pre><p><img src="../assets/figs/random_circuit.png" alt/></p><p>This approach to creating and visualizing random quantum circuits showcases the versatility and capabilities of the package in simulating various quantum computing scenarios.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../advanced/">Advanced Examples »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Thursday 4 July 2024 14:56">Thursday 4 July 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
