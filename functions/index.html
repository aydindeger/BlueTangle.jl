<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Functions · BlueTangle.jl</title><meta name="title" content="Functions · BlueTangle.jl"/><meta property="og:title" content="Functions · BlueTangle.jl"/><meta property="twitter:title" content="Functions · BlueTangle.jl"/><meta name="description" content="Documentation for BlueTangle.jl."/><meta property="og:description" content="Documentation for BlueTangle.jl."/><meta property="twitter:description" content="Documentation for BlueTangle.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="BlueTangle.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">BlueTangle.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../advanced/">Advanced Examples</a></li><li class="is-active"><a class="tocitem" href>Functions</a><ul class="internal"><li><a class="tocitem" href="#Measurement-functions"><span>Measurement functions</span></a></li><li><a class="tocitem" href="#Circuit-functions"><span>Circuit functions</span></a></li><li><a class="tocitem" href="#Quantum-Toolkit"><span>Quantum Toolkit</span></a></li><li><a class="tocitem" href="#Other"><span>Other</span></a></li><li><a class="tocitem" href="#Object-types"><span>Object types</span></a></li><li><a class="tocitem" href="#Gates"><span>Gates</span></a></li><li><a class="tocitem" href="#Noise"><span>Noise</span></a></li><li><a class="tocitem" href="#Hamiltonian"><span>Hamiltonian</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Functions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/aydindeger/BlueTangle.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/aydindeger/BlueTangle.jl/blob/main/docs/src/functions.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h1><p>Detailed explanations or additional notes about all functions.</p><h2 id="Measurement-functions"><a class="docs-heading-anchor" href="#Measurement-functions">Measurement functions</a><a id="Measurement-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Measurement-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BlueTangle.sample" href="#BlueTangle.sample"><code>BlueTangle.sample</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sample(state::sa.SparseVector, shots::Int) -&gt; Vector</code></pre><p>Sample outcomes from a quantum state vector based on the probability distribution.</p><ul><li><code>state</code>: A sparse quantum state vector.</li><li><code>shots</code>: Number of samples to be taken.</li></ul><p>Returns a vector of sampled outcomes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/ops.jl#L11-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BlueTangle.get_probs_from_sample" href="#BlueTangle.get_probs_from_sample"><code>BlueTangle.get_probs_from_sample</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_probs_from_sample(sample::Vector, N::Int) -&gt; (Vector, Vector)</code></pre><p>Convert a sample of outcomes into probabilities.</p><ul><li><code>sample</code>: A vector of sampled outcomes.</li><li><code>N</code>: Number of qubits.</li></ul><p>Returns a tuple of vectors: the first vector contains outcomes, and the second vector contains corresponding probabilities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/ops.jl#L41-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BlueTangle.expect" href="#BlueTangle.expect"><code>BlueTangle.expect</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Alias:</p><pre><code class="nohighlight hljs">expect(m::Measurement, qubit::Int) -&gt; Float64
expect(m::Measurement) -&gt; Vector</code></pre><p>Calculate the expectation value from a measurement.</p><ul><li><code>m</code>: A <code>Measurement</code> object.</li><li><code>qubit</code>: (Optional) Specific qubit for which to calculate the expectation value.</li></ul><p>Returns the expectation value(s).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/func.jl#L25-L38">source</a></section><section><div><p>Alias for density matrix:</p><pre><code class="nohighlight hljs">expect(state::sa.SparseVector, op::QuantumOps) -&gt; Float64
expect(state::sa.SparseVector, op_str::String, qubit::Int) -&gt; Float64
expect(state::sa.SparseVector, matrix::sa.SparseMatrixCSC) -&gt; Float64
expect(state::sa.SparseVector, op_str::String) -&gt; Vector{Float64}</code></pre><p>Alias for state vector:</p><pre><code class="nohighlight hljs">expect(rho::sa.SparseMatrixCSC, op::QuantumOps) -&gt; Float64
expect(rho::sa.SparseMatrixCSC, op_str::String, qubit::Int) -&gt; Float64
expect(rho::sa.SparseMatrixCSC, matrix::sa.SparseMatrixCSC) -&gt; Float64
expect(rho::sa.SparseMatrixCSC, op_str::String) -&gt; Vector{Float64}</code></pre><p>Calculate the expectation value for quantum states or density matrices given an operator. This function has several forms depending on the input parameters:</p><ul><li><p><code>expect(state::sa.SparseVector, op::QuantumOps)</code>: Computes the expectation value for a quantum state vector with a given operator.</p></li><li><p><code>expect(rho::sa.SparseMatrixCSC, op::QuantumOps)</code>: Computes the expectation value for a density matrix with a given operator.</p></li><li><p><code>expect(state::sa.SparseVector, op_str::String, qubit::Int)</code>: Computes the expectation value for a specific qubit in a quantum state vector with an operator specified as a string.</p></li><li><p><code>expect(rho::sa.SparseMatrixCSC, op_str::String, qubit::Int)</code>: Computes the expectation value for a specific qubit in a density matrix with an operator specified as a string.</p></li><li><p><code>expect(state::sa.SparseVector, op_str::String)</code>: Computes the expectation values for all qubits in a quantum state vector given an operator as a string.</p></li><li><p><code>expect(rho::sa.SparseMatrixCSC, op_str::String)</code>: Computes the expectation values for all qubits in a density matrix given an operator as a string.</p></li><li><p><code>expect(state::sa.SparseVector, matrix::sa.SparseMatrixCSC)</code>: Computes the expectation value using a sparse matrix representation of an operator for a state vector.</p></li><li><p><code>expect(rho::sa.SparseMatrixCSC, matrix::sa.SparseMatrixCSC)</code>: Computes the expectation value using a sparse matrix representation of an operator for a density matrix.</p></li></ul><p><strong>Arguments</strong></p><ul><li><code>state::sa.SparseVector</code>: The quantum state vector.</li><li><code>rho::sa.SparseMatrixCSC</code>: The density matrix.</li><li><code>op::QuantumOps</code>: The quantum operator.</li><li><code>op_str::String</code>: The string representation of the operator.</li><li><code>qubit::Int</code>: The specific qubit index.</li><li><code>matrix::sa.SparseMatrixCSC</code>: The sparse matrix representation of the operator.</li></ul><p><strong>Returns</strong></p><ul><li>The expectation value as a <code>Float64</code> or a vector of <code>Float64</code> for multiple qubits.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/func.jl#L45-L90">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BlueTangle.correlation" href="#BlueTangle.correlation"><code>BlueTangle.correlation</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>correlation(m::Measurement, qubits::Vector) -&gt; Any</code></p><p>Calculate correlation from a measurement on specified qubits.</p><ul><li><code>m</code>: A <code>Measurement</code> object.</li><li><code>qubits</code>: Vector of qubits for measuring correlations, e.g. eg: qubits=[1,3] measure &lt;Z1Z3&gt;</li></ul><p>Returns the calculated correlation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/func.jl#L4-L13">source</a></section><section><div><p>Alias:</p><pre><code class="nohighlight hljs">correlation(state::sa.SparseVector, list_of_operators::String, qubits_applied::Vector) -&gt; Float64
correlation(rho::sa.SparseMatrixCSC, list_of_operators::String, qubits_applied::Vector) -&gt; Float64</code></pre><p>Calculate the correlation for a given set of operators applied to specific qubits in either a quantum state vector or a density matrix. This function has two primary forms:</p><ul><li><p><code>correlation(state::sa.SparseVector, list_of_operators::String, qubits_applied::Vector)</code>: Computes the correlation for a quantum state vector (<code>state</code>) with a specified list of operators and qubits.</p></li><li><p><code>correlation(rho::sa.SparseMatrixCSC, list_of_operators::String, qubits_applied::Vector)</code>: Computes the correlation for a density matrix (<code>rho</code>) with a specified list of operators and qubits.</p></li></ul><p>The <code>corr_from_rho</code> function is an alias to <code>get_corr</code> for density matrices.</p><p><strong>Arguments</strong></p><ul><li><code>state::sa.SparseVector</code>: The quantum state vector.</li><li><code>rho::sa.SparseMatrixCSC</code>: The density matrix.</li><li><code>list_of_operators::String</code>: A string representing a list of operators, e.g., &quot;Z,Z&quot;.</li><li><code>qubits_applied::Vector</code>: A vector of qubit indices on which the operators are applied.</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: The computed correlation value.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># For a state vector
state = sa.SparseVector([...]) # define your state vector
correlation = correlation(state, &quot;Z,Z&quot;, [2, 4])

# For a density matrix
rho = sa.SparseMatrixCSC([...]) # define your density matrix
correlation = correlation(rho, &quot;Z,Z&quot;, [2, 4])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/func.jl#L103-L138">source</a></section></article><h2 id="Circuit-functions"><a class="docs-heading-anchor" href="#Circuit-functions">Circuit functions</a><a id="Circuit-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Circuit-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BlueTangle.compile" href="#BlueTangle.compile"><code>BlueTangle.compile</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compile(ops::Vector{&lt;: QuantumOps}, options::Options=Options()) -&gt; Circuit</code></pre><p>Compile a set of quantum operations into a circuit.</p><ul><li><code>ops</code>: A vector of <code>QuantumOps</code> objects.</li><li><code>options</code>: Optional compilation options.</li></ul><p>Returns a compiled <code>Circuit</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/ops.jl#L315-L324">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BlueTangle.measure" href="#BlueTangle.measure"><code>BlueTangle.measure</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>measure(state::sa.SparseVector,number_of_experiment::Int)</code></p><p>this creates a measurement object from state vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/ops.jl#L395-L399">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BlueTangle.measure_ZNE" href="#BlueTangle.measure_ZNE"><code>BlueTangle.measure_ZNE</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>measure_ZNE(circuit::Circuit, number_of_experiment::Int) -&gt; Measurement</code></p><p>Measure a quantum circuit multiple times.</p><ul><li><code>circuit</code>: A <code>Circuit</code> object.</li><li><code>number_of_experiment</code>: Number of times to execute the circuit.</li></ul><p>Returns a <code>Measurement</code> object with the results.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/ops.jl#L351-L360">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BlueTangle.to_state" href="#BlueTangle.to_state"><code>BlueTangle.to_state</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>to_state(circuit::Circuit; init_state::sa.SparseVector=sa.sparse([])) -&gt; sa.SparseVector</code></p><p>Convert a quantum circuit to a state vector.</p><ul><li><code>circuit</code>: A <code>Circuit</code> object.</li><li><code>init_state</code>: (Optional) Initial state vector.</li></ul><p>Returns a state vector representing the circuit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/ops.jl#L534-L543">source</a></section><section><div><p>to_state(MPS::it.ITensors.MPS,M::Vector{it.Index{Int64}})</p><pre><code class="nohighlight hljs">Convert MPS to state vector</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/tensor.jl#L41-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BlueTangle.to_rho" href="#BlueTangle.to_rho"><code>BlueTangle.to_rho</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">to_rho(circuit::Circuit) -&gt; sa.SparseMatrixCSC</code></pre><p>Convert a quantum circuit to a density matrix (rho).</p><ul><li><code>circuit</code>: A <code>Circuit</code> object.</li></ul><p>Returns a density matrix representing the circuit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/ops.jl#L598-L606">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BlueTangle.to_MPS" href="#BlueTangle.to_MPS"><code>BlueTangle.to_MPS</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">to_MPS(vec::sa.SparseVector,M::Vector{it.Index{Int64}})

Convert state vector to MPS</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/tensor.jl#L67-L71">source</a></section></article><h2 id="Quantum-Toolkit"><a class="docs-heading-anchor" href="#Quantum-Toolkit">Quantum Toolkit</a><a id="Quantum-Toolkit-1"></a><a class="docs-heading-anchor-permalink" href="#Quantum-Toolkit" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BlueTangle.entanglement_entropy" href="#BlueTangle.entanglement_entropy"><code>BlueTangle.entanglement_entropy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">entanglement_entropy(psi::sa.SparseVector) -&gt; Float64</code></pre><p>Calculates the entanglement entropy of a quantum state.</p><ul><li><code>psi</code>: The quantum state vector (sa.SparseVector) for which to calculate the entropy.</li></ul><p>Returns the calculated entanglement entropy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/func.jl#L290-L298">source</a></section><section><div><pre><code class="language-julia hljs">entanglement_entropy(rho::sa.SparseMatrixCSC) -&gt; Float64</code></pre><p>Calculates the entanglement entropy of a density matrix.</p><ul><li><code>rho</code>: The density matrix (sa.SparseMatrixCSC) for which to calculate the entropy.</li></ul><p>Returns the calculated entanglement entropy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/func.jl#L316-L324">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BlueTangle.shadow" href="#BlueTangle.shadow"><code>BlueTangle.shadow</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>shadow(circuit::Circuit, number_of_experiment::Int) -&gt; sa.SparseMatrixCSC</code></p><p>Construct a density matrix (rho) from classical shadow representation.</p><ul><li><code>circuit</code>: A <code>Circuit</code> object.</li><li><code>number_of_experiment</code>: Number of experiments to run.</li></ul><p>Returns a sparse density matrix representing the classical shadow.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/ops.jl#L118-L127">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BlueTangle.mag_moments" href="#BlueTangle.mag_moments"><code>BlueTangle.mag_moments</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>mag_moments(rho::sa.SparseMatrixCSC, op_str::String, moment_order::Int) -&gt; Float64</code></p><p>Calculates the magnetization moments from a given density matrix.</p><ul><li><code>rho</code>: The density matrix (sa.SparseMatrixCSC) of the quantum system.</li><li><code>op_str</code>: String representation of the operator used for calculating the magnetization.</li><li><code>moment_order</code>: The order of the magnetization moment to compute.</li></ul><p>Returns the computed magnetization moment of the specified order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/func.jl#L188-L198">source</a></section><section><div><p>calculates average magnetization moments from sample</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/func.jl#L228-L230">source</a></section></article><h2 id="Other"><a class="docs-heading-anchor" href="#Other">Other</a><a id="Other-1"></a><a class="docs-heading-anchor-permalink" href="#Other" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BlueTangle.get_N" href="#BlueTangle.get_N"><code>BlueTangle.get_N</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_N(state::sa.SparseVector) -&gt; Int
get_N(rho::sa.SparseMatrixCSC) -&gt; Int</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/ops.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BlueTangle.fock_basis_create" href="#BlueTangle.fock_basis_create"><code>BlueTangle.fock_basis_create</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fock_basis_create(N::Int)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/bit.jl#L35-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BlueTangle.hilbert" href="#BlueTangle.hilbert"><code>BlueTangle.hilbert</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>hilbert(N::Int, mat::AbstractMatrix, qubit::Int, target_qubit::Int)</code></p><p>Constructs a sparse matrix representing the action of a quantum gate in a Hilbert space associated with a quantum system of <code>N</code> qubits</p><p>The gate <code>mat</code> is applied to the <code>qubit</code> and<code>target_qubit</code>. If <code>qubit</code> is greater than <code>target_qubit</code>, a controlled  swap is performed before applying <code>mat</code>.</p><p><strong>Arguments</strong></p><ul><li><code>N::Int</code>: The number of qubits in the system.</li><li><code>mat::AbstractMatrix</code>: The quantum gate to be applied.</li><li><code>qubit::Int</code>: The qubit to which the gate is applied.</li><li><code>target_qubit::Int</code>: The target qubit to which the gate is applied.</li></ul><p><strong>Returns</strong></p><p><code>SparseMatrix</code>: The resulting sparse matrix representation of the gate operation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/hilbert.jl#L1-L17">source</a></section><section><div><p><code>hilbert(N::Int, mat::AbstractMatrix, qubit::Int)</code></p><p>Constructs a sparse matrix representing the action of a quantum gate in a Hilbert space associated with a quantum system of <code>N</code> qubits.</p><p><strong>Arguments</strong></p><ul><li><code>N::Int</code>: The number of qubits in the system.</li><li><code>mat::AbstractMatrix</code>: The quantum gate to be applied.</li><li><code>qubit::Int</code>: The qubit to which the gate is applied.</li></ul><p><strong>Returns</strong></p><p><code>SparseMatrix</code>: The resulting sparse matrix representation of the gate operation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/hilbert.jl#L87-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BlueTangle.expand_multi_op" href="#BlueTangle.expand_multi_op"><code>BlueTangle.expand_multi_op</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>expand_multi_op(list_of_operators::String, qubits_applied::Vector, N::Int) -&gt; Matrix</code></p><p>Expand multiple quantum operators over a specified set of qubits.</p><ul><li><code>list_of_operators</code>: A string representing a list of operators.</li><li><code>qubits_applied</code>: A vector of qubits on which operators are applied.</li><li><code>N</code>: Total number of qubits.</li></ul><p>Returns a matrix representing the expanded operators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/ops.jl#L717-L727">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BlueTangle.string_to_matrix" href="#BlueTangle.string_to_matrix"><code>BlueTangle.string_to_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>string_to_matrix(list_of_operators::String) -&gt; Matrix</code></p><p>Convert a string of comma-separated operators into a matrix representation.</p><ul><li><code>list_of_operators</code>: A string representing a list of operators, e.g.: &quot;Z,Z,sa.IP(.2)&quot;</li></ul><p>Returns a matrix representation of the operators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/ops.jl#L746-L754">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BlueTangle.zero_state" href="#BlueTangle.zero_state"><code>BlueTangle.zero_state</code></a> — <span class="docstring-category">Function</span></header><section><div><p>zero_state(N::Int) -&gt; sa.SparseVector</p><p>Returns a sparse vector representing the |000...&gt; quantum state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/hilbert.jl#L506-L510">source</a></section><section><div><p>create all zero state</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/tensor.jl#L8-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BlueTangle.one_state" href="#BlueTangle.one_state"><code>BlueTangle.one_state</code></a> — <span class="docstring-category">Function</span></header><section><div><p>create all one state</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/tensor.jl#L13-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BlueTangle.product_state" href="#BlueTangle.product_state"><code>BlueTangle.product_state</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>product_state(list_of_qubits::Vector) -&gt; sa.SparseVector</code></p><p>Creates a quantum state vector from a list of qubits.</p><ul><li><code>list_of_qubits</code>: A vector representing the state of each qubit.</li></ul><p>Returns a sparse vector representing the quantum state of the system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/hilbert.jl#L471-L479">source</a></section><section><div><p>create given product state</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/tensor.jl#L18-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BlueTangle.neel_state01" href="#BlueTangle.neel_state01"><code>BlueTangle.neel_state01</code></a> — <span class="docstring-category">Function</span></header><section><div><p>create neel state 010101</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/tensor.jl#L23-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BlueTangle.neel_state10" href="#BlueTangle.neel_state10"><code>BlueTangle.neel_state10</code></a> — <span class="docstring-category">Function</span></header><section><div><p>create neel state 101010</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/tensor.jl#L28-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BlueTangle.apply" href="#BlueTangle.apply"><code>BlueTangle.apply</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>apply(state::sa.SparseVector, op::QuantumOps)</code></p><p>Apply a quantum gate operation to a state vector in place.</p><ul><li><code>state</code>: A sparse quantum state vector to be modified.</li><li><code>op</code>: A <code>QuantumOps</code> object representing the gate operation.</li></ul><p>Modifies the state vector directly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/hilbert.jl#L212-L221">source</a></section><section><div><p><code>apply(rho::sa.SparseMatrixCSC, op::QuantumOps)</code></p><p>Apply a quantum gate operation to a state vector in place.</p><ul><li><code>rho</code>: A sparse quantum density matrix to be modified.</li><li><code>op</code>: A <code>QuantumOps</code> object representing the gate operation.</li></ul><p>Modifies the state vector directly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/hilbert.jl#L292-L301">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BlueTangle.linear_fit" href="#BlueTangle.linear_fit"><code>BlueTangle.linear_fit</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">linear_fit(xdata::Vector, ydata::Vector)</code></pre><p>Compute the coefficients a and b for the linear fit of the given data.</p><p><strong>Arguments</strong></p><ul><li><code>xdata</code>: Array of x values.</li><li><code>ydata</code>: Array of corresponding y values.</li></ul><p><strong>Returns</strong></p><ul><li><code>a</code>: Intercept of the linear fit.</li><li><code>b</code>: Slope of the linear fit.</li><li><code>se_a</code>: Standard error of the intercept.</li><li><code>se_b</code>: Standard error of the slope.</li></ul><p><strong>Description</strong></p><p>This function fits a simple linear model (y = a + b*x) to the provided data points. It checks if the lengths of xdata and ydata are the same and then calculates the coefficients for the linear fit. Additionally, it computes the standard errors for both the slope and the intercept.</p><p>The function uses the least squares method for the linear regression. The standard errors are calculated based on the residual sum of squares and the total sum of squares for the x values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/linalg.jl#L349-L371">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BlueTangle.quadratic_fit" href="#BlueTangle.quadratic_fit"><code>BlueTangle.quadratic_fit</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">quadratic_fit(xdata::Vector{Float64}, ydata::Vector{Float64}) -&gt; Vector{Float64}</code></pre><p>Fit a quadratic function to the given data.</p><p><strong>Arguments</strong></p><ul><li><code>xdata::Vector{Float64}</code>: A vector of x-coordinates.</li><li><code>ydata::Vector{Float64}</code>: A vector of y-coordinates corresponding to <code>xdata</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Float64}</code>: The coefficients <code>[a, b, c]</code> of the fitted quadratic function <code>y = ax^2 + bx + c</code>.</li></ul><p><strong>Description</strong></p><p>This function performs a least squares quadratic fit to the input data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/linalg.jl#L406-L420">source</a></section></article><h2 id="Object-types"><a class="docs-heading-anchor" href="#Object-types">Object types</a><a id="Object-types-1"></a><a class="docs-heading-anchor-permalink" href="#Object-types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BlueTangle.QuantumOps" href="#BlueTangle.QuantumOps"><code>BlueTangle.QuantumOps</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>QuantumOps</code></p><p>Abstract type representing quantum operations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/struct.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BlueTangle.Op" href="#BlueTangle.Op"><code>BlueTangle.Op</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Op(q::Int, name::String, mat::AbstractMatrix, qubit::Int, target_qubit::Int, noise::QuantumChannel) &lt;: QuantumOps</code></p><p>Represents a quantum operation.</p><ul><li><code>q</code>: Number of qubits involved in the operation.</li><li><code>name</code>: Name of the operation.</li><li><code>mat</code>: Matrix representation of the quantum operation.</li><li><code>qubit</code>: Index of the target qubit.</li><li><code>target_qubit</code>: Index of the target qubit for two-qubit operations.</li><li><code>noise</code>: Noise model associated with the operation.</li></ul><p>Constructs an Op object representing a quantum operation with optional noise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/struct.jl#L341-L354">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BlueTangle.ifOp" href="#BlueTangle.ifOp"><code>BlueTangle.ifOp</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>ifOp(q::Int, name::String, mat::AbstractMatrix, qubit::Int, if01::Tuple{Matrix,Matrix}, noise::QuantumChannel) &lt;: QuantumOps</code></p><p>Represents a conditional quantum operation used for mid-circuit born measurements. It is specifically designed for mid-circuit measurements in the X, Y, Z, or a random basis (R). Depending on the measurement outcomes (0 or 1), different gates specified in <code>if01</code> can be applied.</p><p><strong>Fields</strong></p><ul><li><code>q</code>: Integer representing the number of qubits involved in the operation.</li><li><code>name</code>: String indicating the name of the operation. Valid names are &quot;MX&quot;, &quot;MY&quot;, &quot;MZ&quot;, or &quot;MR&quot;, corresponding to operations in the X, Y, Z basis, or a random basis (R), respectively.</li><li><code>mat</code>: Matrix representing the quantum operation.</li><li><code>qubit</code>: Integer specifying the index of the target qubit.</li><li><code>if01</code>: Tuple of two matrices. The first matrix is applied if the measured state of the qubit is 0, and the second matrix is applied if the measured state is 1.</li><li><code>noise</code>: Represents a &#39;born measurement quantum channel&#39;, indicating the noise model associated with the operation.</li></ul><p><strong>Usage</strong></p><p><code>ifOp</code> is constructed to represent quantum operations that are conditional on the measurement outcome of a qubit. This operator is particularly useful in quantum circuits for implementing dynamic responses based on mid-circuit measurement results.</p><p><strong>Examples</strong></p><p>```julia</p><p><strong>Example of creating an ifOp for a conditional operation based on the X-basis measurement (MX)</strong></p><p>conditional<em>op = ifOp(&quot;MX&quot;, qubit, (operation</em>if<em>0, operation</em>if_1))</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/struct.jl#L585-L605">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BlueTangle.Measurement" href="#BlueTangle.Measurement"><code>BlueTangle.Measurement</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Measurement(bitstr::Union{Vector, UnitRange}, sample::Vector, expect::Vector, mag_moments::Vector, measurement_basis::String, number_of_experiment::Int, circuit_name::String, number_of_qubits::Int, density_matrix::sa.SparseMatrixCSC)</code></p><p>Represents the result of quantum measurements.</p><ul><li><code>bitstr</code>: Basis of measurement represented as integers or a range.</li><li><code>sample</code>: Vector of probabilities.</li><li><code>expect</code>: Expectation values of the measurement.</li><li><code>mag_moments</code>: Magnetic moments obtained from the measurement.</li><li><code>measurement_basis</code>: Measurement basis used.</li><li><code>number_of_experiment</code>: Number of experiments performed.</li><li><code>circuit_name</code>: Name of the circuit used.</li><li><code>number_of_qubits</code>: Number of qubits involved.</li><li><code>density_matrix</code>: Density matrix obtained from the measurement.</li></ul><p>Constructs a Measurement object to store the results of quantum measurements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/struct.jl#L786-L802">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BlueTangle.QuantumChannel" href="#BlueTangle.QuantumChannel"><code>BlueTangle.QuantumChannel</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>QuantumChannel(q::Int, model::String, p::Float64)</code></p><p>Represents a quantum noise channel.</p><ul><li><code>q</code>: Number of qubits affected by the noise channel.</li><li><code>model</code>: The noise model type as a string.</li><li><code>p</code>: Probability parameter for the noise model.</li><li><code>kraus</code>: A vector of matrices representing Kraus operators for the channel.</li></ul><p>Constructs a QuantumChannel object for specified qubits, noise model, and probability.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/struct.jl#L77-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BlueTangle.NoiseModel" href="#BlueTangle.NoiseModel"><code>BlueTangle.NoiseModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Create a NoiseModel</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/struct.jl#L208-L210">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BlueTangle.AnsatzOptions" href="#BlueTangle.AnsatzOptions"><code>BlueTangle.AnsatzOptions</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AnsatzOptions(; N::Int, ops::Union{Vector{String},Vector{&lt;:QuantumOps}}, noise=false, init::Union{sa.SparseVector,Circuit}=sa.sparse([]), model::String=&quot;lbfgs&quot;, number_of_iterations::Int=1000, learning_rate::Float64=0.01, pars_initial::Vector=[], deep_circuit::Bool=false, history::Bool=true)</code></pre><p>Constructs an <code>AnsatzOptions</code> object that contains the configuration for a variational quantum circuit ansatz.</p><p><strong>Arguments</strong></p><ul><li><code>N::Int</code>: The number of qubits in the ansatz.</li><li><code>ops::Union{Vector{String},Vector{&lt;:QuantumOps}}</code>: The quantum operations defining the ansatz, either as a vector of strings or a vector of <code>QuantumOps</code>.</li><li><code>noise=false</code>: Specifies whether to include noise in the ansatz. Can be either a <code>NoiseModel</code> or a boolean value.</li><li><code>init::Union{sa.SparseVector,Circuit}=sa.sparse([])</code>: The initial state of the ansatz, either as a sparse vector or a <code>Circuit</code>. Defaults to the zero state.</li><li><code>model::String=&quot;lbfgs&quot;</code>: The optimization model to use. Can be &quot;lbfgs&quot;, &quot;adam&quot;, &quot;descent&quot;, &quot;radam&quot;, &quot;momentum&quot;, or &quot;nesterov&quot;.</li><li><code>number_of_iterations::Int=1000</code>: The number of iterations for the optimization.</li><li><code>learning_rate::Float64=0.01</code>: The learning rate for the optimization.</li><li><code>pars_initial::Vector=[]</code>: The initial parameters for the ansatz. If not provided, random parameters are generated.</li><li><code>deep_circuit::Bool=false</code>: Specifies whether to use a deep circuit ansatz.</li><li><code>history::Bool=true</code>: Specifies whether to record the optimization history.</li></ul><p><strong>Returns</strong></p><ul><li>An <code>AnsatzOptions</code> object containing the configuration for the variational quantum circuit ansatz.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/vqe.jl#L69-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BlueTangle.Circuit" href="#BlueTangle.Circuit"><code>BlueTangle.Circuit</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Circuit</code></p><p>Represents a quantum circuit.</p><ul><li><code>stats</code>: NamedTuple containing statistics about the circuit.</li><li><code>options</code>: Options object with circuit configurations.</li><li><code>ops</code>: Vector of QuantumOps representing the operations in the circuit.</li></ul><p>Constructs a Circuit object representing a quantum circuit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/struct.jl#L759-L769">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BlueTangle.Options" href="#BlueTangle.Options"><code>BlueTangle.Options</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Options(circuit_name::String, measurement_basis::String, final_measurement_noise::QuantumChannel, Noise1::QuantumChannel, Noise2::QuantumChannel, twirl::Bool, noisy_swap::Bool, density_matrix::Bool)</code></p><p>Represents configuration options for a quantum circuit.</p><ul><li><code>circuit_name</code>: Name of the circuit.</li><li><code>measurement_basis</code>: Measurement basis used in the circuit.</li><li><code>final_measurement_noise</code>: Noise model for final measurement error.</li><li><code>noise</code>: Noise model for single-qubit and two-qubit operations.</li><li><code>twirl</code>: Boolean flag for twirling operations.</li><li><code>noisy_swap</code>: Boolean flag for swap errors.</li><li><code>density_matrix</code>: Boolean flag to indicate if density matrix should be calculated.</li></ul><p>Constructs an Options object with specified settings for a quantum circuit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/struct.jl#L723-L737">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BlueTangle.Layout" href="#BlueTangle.Layout"><code>BlueTangle.Layout</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Create Layout</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/struct.jl#L670-L672">source</a></section></article><h2 id="Gates"><a class="docs-heading-anchor" href="#Gates">Gates</a><a id="Gates-1"></a><a class="docs-heading-anchor-permalink" href="#Gates" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BlueTangle.gate" href="#BlueTangle.gate"><code>BlueTangle.gate</code></a> — <span class="docstring-category">Constant</span></header><section><div><p><code>gate</code></p><p>A constant that holds common quantum gates and projectors.</p><p>This includes:</p><ul><li>Identity (<code>I</code>)</li><li>Pauli gates (<code>X</code>, <code>Y</code>, <code>Z</code>)</li><li>Hadamard (<code>H</code>)</li><li>Phase gates (<code>S</code>, <code>T</code>)</li><li>Special gates like <code>sqrt(X)</code> (equal to RX(pi/2)<em>exp(1im</em>pi/4))</li><li>Projectors (<code>P0</code> for |0&gt;&lt;0|, <code>P1</code> for |1&gt;&lt;1|)</li><li>Controlled gates such as <code>CX</code> (CNOT), <code>CNOT</code> (an alias for CX), and <code>CZ</code></li><li>The <code>SWAP</code>, <code>ISWAP</code>, <code>FSWAP</code> gate</li><li>The <code>ECR</code>, <code>SYC</code> gate</li></ul><p>Each single-qubit gate is represented as a 2x2 matrix, while multi-qubit gates like <code>CNOT</code>, <code>ECR</code>, <code>SYC</code>, <code>CZ</code>, and <code>SWAP</code>, <code>ISWAP</code>, <code>FSWAP</code> are represented as 4x4 matrices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/gates.jl#L4-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BlueTangle.random_ops" href="#BlueTangle.random_ops"><code>BlueTangle.random_ops</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>random_ops_2(N::Int, len::Int; measure_prob::Float64=0.0, measure_basis::Vector{String}=[&quot;MX&quot;, &quot;MY&quot;, &quot;MZ&quot;]) -&gt; Vector{QuantumOps}</code></p><p>Create a sequence of random quantum gate operations, with optional mid-circuit measurements.</p><p><strong>Arguments</strong></p><ul><li><code>N::Int</code>: The number of qubits in the system.</li><li><code>len::Int</code>: The length of the sequence of operations to generate.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>measure_prob::Float64</code>: The probability of adding a measurement operation after each gate.</li><li><code>measure_basis::Vector{String}</code>: The basis in which measurements are performed.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{QuantumOps}</code>: A vector of randomly chosen quantum operations (<code>QuantumOps</code>), each representing a gate or a measurement operation.</li></ul><p><strong>Description</strong></p><p>This function creates a vector of quantum operations, where each operation is either a randomly chosen gate from the set {&quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;, &quot;H&quot;, &quot;S&quot;, &quot;CX&quot;,&quot;CZ&quot;,&quot;CP&quot;,&quot;GIVENS&quot;,&quot;FSIM&quot;,&quot;SWAP&quot;,&quot;ISWAP&quot;,&quot;FSWAP&quot;,&quot;SYC&quot;,&quot;ECR&quot;} or a measurement operation, based on <code>measure_prob</code>. </p><p><strong>Example</strong></p><pre><code class="language-julia hljs">ops = random_ops(5, 10; measure_prob=0.2, measure_basis=[&quot;MX&quot;,&quot;MZ&quot;])</code></pre><p>This example generates a sequence of 10 random gates and measurements (with a 20% chance of a measurement after each gate) for a 5-qubit system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/gates.jl#L111-L135">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BlueTangle.random_clifford" href="#BlueTangle.random_clifford"><code>BlueTangle.random_clifford</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>random_clifford(N::Int, len::Int; measure_prob::Float64=0.0, measure_basis::Vector{String}=[&quot;MX&quot;,&quot;MY&quot;,&quot;MZ&quot;]) -&gt; Vector{QuantumOps}</code></p><p>Generate a random sequence of Clifford gates, with optional mid-circuit measurements.</p><p><strong>Arguments</strong></p><ul><li><code>N::Int</code>: The number of qubits in the system.</li><li><code>len::Int</code>: The length of the sequence of operations to generate.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>measure_prob::Float64</code>: The probability of adding a measurement operation after each gate.</li><li><code>measure_basis::Vector{String}</code>: The basis in which measurements are performed.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{QuantumOps}</code>: A vector of randomly chosen quantum operations (<code>QuantumOps</code>), each representing a Clifford gate or a measurement operation.</li></ul><p><strong>Description</strong></p><p>This function creates a vector of quantum operations, where each operation is either a randomly chosen Clifford gate from the set {&quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;, &quot;H&quot;, &quot;S&quot;, &quot;CNOT&quot;, &quot;SWAP&quot;, &quot;CZ&quot;} or a measurement operation, based on <code>measure_prob</code>. For two-qubit gates (&quot;CNOT&quot;, &quot;SWAP&quot;, &quot;CZ&quot;), adjacent qubits (qubit <code>r</code> and qubit <code>r+1</code>) are selected. For single-qubit gates and measurements, a random qubit <code>r</code> is chosen.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">ops = random_clifford(5, 10; measure_prob=0.2, measure_basis=[&quot;MX&quot;,&quot;MZ&quot;])</code></pre><p>This example generates a sequence of 10 random Clifford gates and measurements (with a 20% chance of a measurement after each gate) for a 5-qubit system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/gates.jl#L196-L220">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BlueTangle.get_stats" href="#BlueTangle.get_stats"><code>BlueTangle.get_stats</code></a> — <span class="docstring-category">Function</span></header><section><div><p>get statistics about the operations</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/ops.jl#L171-L173">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BlueTangle.get_layers" href="#BlueTangle.get_layers"><code>BlueTangle.get_layers</code></a> — <span class="docstring-category">Function</span></header><section><div><p>get_layers for a given set of ops</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/ops.jl#L258-L260">source</a></section></article><h2 id="Noise"><a class="docs-heading-anchor" href="#Noise">Noise</a><a id="Noise-1"></a><a class="docs-heading-anchor-permalink" href="#Noise" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BlueTangle.is_valid_quantum_channel" href="#BlueTangle.is_valid_quantum_channel"><code>BlueTangle.is_valid_quantum_channel</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>is_valid_quantum_channel(kraus::Vector{Matrix}) -&gt; Bool</code></p><p>Determines the validity of a set of Kraus operators.</p><ul><li><code>kraus</code>: A vector of matrices, each representing a Kraus operator.</li></ul><p>This function checks if the provided Kraus operators form a valid quantum channel.  It does so by verifying if the sum of the products of each Kraus operator and its adjoint  (approximately) equals the identity matrix. Returns <code>true</code> if the set is valid, <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/struct.jl#L269-L279">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BlueTangle.Noise1" href="#BlueTangle.Noise1"><code>BlueTangle.Noise1</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>Noise1(model::String, p::Float64)</code></p><p>Constructors for QuantumChannel objects for 1 qubit.</p><ul><li><code>model</code>: The noise model type as a string.</li><li><code>p</code>: Probability parameter for the noise model.</li></ul><p>Returns a QuantumChannel object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/struct.jl#L315-L324">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BlueTangle.Noise2" href="#BlueTangle.Noise2"><code>BlueTangle.Noise2</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>Noise2(model::String, p::Float64)</code></p><p>Constructors for QuantumChannel objects for 2 qubits.</p><ul><li><code>model</code>: The noise model type as a string.</li><li><code>p</code>: Probability parameter for the noise model.</li></ul><p>Returns a QuantumChannel object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/struct.jl#L327-L336">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BlueTangle.apply_noise" href="#BlueTangle.apply_noise"><code>BlueTangle.apply_noise</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">apply noise on qubit or target_qubit of a given state and noise model</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/hilbert.jl#L175-L177">source</a></section><section><div><p>apply noise on qubit or target_qubit of a given density matrix and noise model</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/hilbert.jl#L193-L195">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BlueTangle.apply_twirl" href="#BlueTangle.apply_twirl"><code>BlueTangle.apply_twirl</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>apply_twirl(op::QuantumOps) -&gt; Vector{QuantumOps}</code></p><p>Applies twirling with specified noise to a single quantum operation.</p><ul><li><code>op</code>: A QuantumOps object representing the quantum operation.</li></ul><p>Returns a vector of QuantumOps representing the twirled operation with noise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/noise.jl#L216-L224">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BlueTangle.cnot_amplifier!" href="#BlueTangle.cnot_amplifier!"><code>BlueTangle.cnot_amplifier!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>cnot_amplifier!(ops::Vector{&lt;:QuantumOps}, CNOT_pair=0)</code></p><p>Amplify the presence of CNOT (or CX) operations in a vector of quantum operations.</p><p>This function adds extra pair of CNOT operation in the <code>ops</code> vector a specific number of times in place. This is useful for amplifying the effect of noise via CNOT operations in a sequence of quantum operations.</p><p><strong>Arguments</strong></p><ul><li><code>ops::Vector{&lt;:QuantumOps}</code>: A vector of quantum operations, where <code>T</code> is a subtype of <code>QuantumOps</code>.</li><li><code>CNOT_pair::Int</code> (optional): The number of additional pairs of CNOT operations to insert for each original CNOT operation in <code>ops</code>. The default value is 0, which means no additional operations are inserted.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">ops = [Op(&quot;H&quot;,1), Op(&quot;CNOT&quot;,1,2), Op(&quot;X&quot;,2)]
cnot_amplifier!(ops, 1)
# `ops` will be modified to: [Op(&quot;H&quot;,1), Op(&quot;CNOT&quot;,1,2), Op(&quot;CNOT&quot;,1,2), Op(&quot;CNOT&quot;,1,2), Op(&quot;X&quot;,2)]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/ops.jl#L484-L501">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BlueTangle.op_amplifier!" href="#BlueTangle.op_amplifier!"><code>BlueTangle.op_amplifier!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>op_amplifier!(ops::Vector{&lt;:QuantumOps},op_pair=0)</code></p><p>same as <code>cnot_amplifier!</code> but for all operations</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/ops.jl#L516-L520">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BlueTangle.error_mitigate_data" href="#BlueTangle.error_mitigate_data"><code>BlueTangle.error_mitigate_data</code></a> — <span class="docstring-category">Function</span></header><section><div><p>error<em>mitigate</em>data(xdata::Vector, ydata::Vector)</p><p>Perform error mitigation on a dataset by fitting a linear model and extracting the estimate and standard error.</p><p>This function takes two vectors <code>xdata</code> and <code>ydata</code> which represent the independent and dependent variables of a dataset, respectively.</p><p><strong>Arguments</strong></p><ul><li><code>xdata::Vector</code>: The independent variable data points.</li><li><code>ydata::Vector</code>: The dependent variable data points, corresponding to each xdata point.</li></ul><p><strong>Returns</strong></p><ul><li><code>est</code>: The estimated intercept from the linear fit.</li><li><code>se</code>: The standard error of the estimated intercept.</li><li><code>fit_plot</code>: A tuple containing the x-values from 0 to the last element of <code>xdata</code> and the corresponding fitted y-values from the model.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/linalg.jl#L440-L455">source</a></section></article><h2 id="Hamiltonian"><a class="docs-heading-anchor" href="#Hamiltonian">Hamiltonian</a><a id="Hamiltonian-1"></a><a class="docs-heading-anchor-permalink" href="#Hamiltonian" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BlueTangle.hamiltonian" href="#BlueTangle.hamiltonian"><code>BlueTangle.hamiltonian</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>hamiltonian(N::Int, string_of_ops::Vector, boundary::String=&quot;open&quot;)</code></p><p>Constructs a Hamiltonian matrix for a quantum system with <code>N</code> qubits. The Hamiltonian is  built based on the operators and their corresponding couplings specified in <code>string_of_ops</code>.</p><p>The <code>string_of_ops</code> should be an alternating array of coupling constants and operator  strings. For example, <code>[.1, &quot;Z,Z&quot;, .5, &quot;X&quot;]</code> implies a system with alternating couplings <code>.1</code> and <code>.5</code>,  and operators &quot;Z,Z&quot; and &quot;X&quot;.</p><p>The <code>boundary</code> parameter specifies the boundary conditions of the system. It can be either  &quot;open&quot; or &quot;periodic&quot;. In the case of &quot;open&quot; boundary conditions, interactions are only included  for sites within the system size. For &quot;periodic&quot; boundary conditions, the system is treated as  if it were wrapped around itself, allowing interactions that cross the end and start of the  chain.</p><p><strong>Arguments</strong></p><ul><li><code>N::Int</code>: The number of qubits in the system.</li><li><code>string_of_ops::Vector</code>: An alternating vector of coupling constants and operator strings.</li><li><code>boundary::String</code>: The boundary condition of the system, either &quot;open&quot; or &quot;periodic&quot; (default is &quot;open&quot;).</li></ul><p><strong>Returns</strong></p><ul><li><code>SparseMatrix</code>: The Hamiltonian matrix representing the specified quantum system.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">N = 6
string_of_ops = [-J, &quot;Z,Z&quot;, -h, &quot;X&quot;]
H = hamiltonian(N, string_of_ops, &quot;open&quot;)</code></pre><p>This function iterates over the operator strings, applies each operator to the appropriate qubits  based on the boundary conditions, and scales them by their corresponding coupling constants  to construct the Hamiltonian.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/vqe.jl#L1-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BlueTangle.hamiltonian_exp" href="#BlueTangle.hamiltonian_exp"><code>BlueTangle.hamiltonian_exp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hamiltonian_exp(N::Int, total_time::Float64, string_of_ops::Vector; dt=0.1) -&gt; Vector{QuantumOps}</code></pre><p>Expands a given Hamiltonian expressed as a string of operations into a sequence of quantum gates using Trotterization.</p><ul><li><code>N</code>: Number of qubits involved in the simulation.</li><li><code>total_time</code>: The total simulation time over which the Hamiltonian is to be applied.</li><li><code>string_of_ops</code>: A vector where odd indices contain the coupling strengths and even indices contain comma-separated strings representing the operators (X, Y, Z) applied to consecutive qubits.</li><li><code>dt</code> (optional): The time step for Trotterization, with a default value of 0.1.</li></ul><p>The function <code>hamiltonian_exp</code> parses the <code>string_of_ops</code> to construct a sequence of operations based on the specified operators and their coupling strengths. For each term in the Hamiltonian:</p><p>This method returns a vector of <code>QuantumOps</code>, each representing a quantum operation to be applied sequentially to simulate the Hamiltonian over the specified time <code>total_time</code>.</p><p><strong>Example</strong></p><p><strong>Define a Hamiltonian for a 3-qubit system with mixed interactions over 2 seconds</strong></p><p>N = 3 total<em>time = 2.0 string</em>of<em>ops = [1.0, &quot;X,Y&quot;, 0.5, &quot;Y,Z&quot;] ops = hamiltonian</em>exp(N, total<em>time, string</em>of_ops)</p><p><strong>ops will contain a sequence of quantum gates to apply.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/trotter.jl#L25-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BlueTangle.VQE" href="#BlueTangle.VQE"><code>BlueTangle.VQE</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">VQE(opt::AnsatzOptions)</code></pre><p>Performs the Variational Quantum Eigensolver (VQE) algorithm to find the optimal state of a given loss function using the variational quantum circuit defined by the <code>AnsatzOptions</code>.</p><p><strong>Arguments</strong></p><ul><li><code>opt::AnsatzOptions</code>: The <code>AnsatzOptions</code> object containing the configuration for the variational quantum circuit.</li></ul><p><strong>Returns</strong></p><ul><li>A tuple containing:<ul><li>The optimization history (energy values) if <code>history=true</code>, otherwise the final energy value.</li><li>The optimized parameters for the variational circuit.</li><li>The final state obtained from the optimized parameters.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/vqe.jl#L312-L325">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BlueTangle.variational_apply" href="#BlueTangle.variational_apply"><code>BlueTangle.variational_apply</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">variational_apply(pars::Vector, opt::AnsatzOptions)</code></pre><p>Applies the variational quantum circuit defined by the <code>AnsatzOptions</code> to the initial state using the given parameters.</p><p><strong>Arguments</strong></p><ul><li><code>pars::Vector</code>: The parameters for the variational circuit.</li><li><code>opt::AnsatzOptions</code>: The <code>AnsatzOptions</code> object containing the configuration for the variational circuit.</li></ul><p><strong>Returns</strong></p><ul><li>The final state after applying the variational circuit.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aydindeger/BlueTangle.jl/blob/34fe2c2475afa20459129d23b4fb95631e948810/src/vqe.jl#L256-L267">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#BlueTangle.gate"><code>BlueTangle.gate</code></a></li><li><a href="#BlueTangle.AnsatzOptions"><code>BlueTangle.AnsatzOptions</code></a></li><li><a href="#BlueTangle.Circuit"><code>BlueTangle.Circuit</code></a></li><li><a href="#BlueTangle.Layout"><code>BlueTangle.Layout</code></a></li><li><a href="#BlueTangle.Measurement"><code>BlueTangle.Measurement</code></a></li><li><a href="#BlueTangle.NoiseModel"><code>BlueTangle.NoiseModel</code></a></li><li><a href="#BlueTangle.Op"><code>BlueTangle.Op</code></a></li><li><a href="#BlueTangle.Options"><code>BlueTangle.Options</code></a></li><li><a href="#BlueTangle.QuantumChannel"><code>BlueTangle.QuantumChannel</code></a></li><li><a href="#BlueTangle.QuantumOps"><code>BlueTangle.QuantumOps</code></a></li><li><a href="#BlueTangle.ifOp"><code>BlueTangle.ifOp</code></a></li><li><a href="#BlueTangle.Noise1"><code>BlueTangle.Noise1</code></a></li><li><a href="#BlueTangle.Noise2"><code>BlueTangle.Noise2</code></a></li><li><a href="#BlueTangle.VQE"><code>BlueTangle.VQE</code></a></li><li><a href="#BlueTangle.apply"><code>BlueTangle.apply</code></a></li><li><a href="#BlueTangle.apply_noise"><code>BlueTangle.apply_noise</code></a></li><li><a href="#BlueTangle.apply_twirl"><code>BlueTangle.apply_twirl</code></a></li><li><a href="#BlueTangle.cnot_amplifier!"><code>BlueTangle.cnot_amplifier!</code></a></li><li><a href="#BlueTangle.compile"><code>BlueTangle.compile</code></a></li><li><a href="#BlueTangle.correlation"><code>BlueTangle.correlation</code></a></li><li><a href="#BlueTangle.entanglement_entropy"><code>BlueTangle.entanglement_entropy</code></a></li><li><a href="#BlueTangle.error_mitigate_data"><code>BlueTangle.error_mitigate_data</code></a></li><li><a href="#BlueTangle.expand_multi_op"><code>BlueTangle.expand_multi_op</code></a></li><li><a href="#BlueTangle.expect"><code>BlueTangle.expect</code></a></li><li><a href="#BlueTangle.fock_basis_create"><code>BlueTangle.fock_basis_create</code></a></li><li><a href="#BlueTangle.get_N"><code>BlueTangle.get_N</code></a></li><li><a href="#BlueTangle.get_layers"><code>BlueTangle.get_layers</code></a></li><li><a href="#BlueTangle.get_probs_from_sample"><code>BlueTangle.get_probs_from_sample</code></a></li><li><a href="#BlueTangle.get_stats"><code>BlueTangle.get_stats</code></a></li><li><a href="#BlueTangle.hamiltonian"><code>BlueTangle.hamiltonian</code></a></li><li><a href="#BlueTangle.hamiltonian_exp"><code>BlueTangle.hamiltonian_exp</code></a></li><li><a href="#BlueTangle.hilbert"><code>BlueTangle.hilbert</code></a></li><li><a href="#BlueTangle.is_valid_quantum_channel"><code>BlueTangle.is_valid_quantum_channel</code></a></li><li><a href="#BlueTangle.linear_fit"><code>BlueTangle.linear_fit</code></a></li><li><a href="#BlueTangle.mag_moments"><code>BlueTangle.mag_moments</code></a></li><li><a href="#BlueTangle.measure"><code>BlueTangle.measure</code></a></li><li><a href="#BlueTangle.measure_ZNE"><code>BlueTangle.measure_ZNE</code></a></li><li><a href="#BlueTangle.neel_state01"><code>BlueTangle.neel_state01</code></a></li><li><a href="#BlueTangle.neel_state10"><code>BlueTangle.neel_state10</code></a></li><li><a href="#BlueTangle.one_state"><code>BlueTangle.one_state</code></a></li><li><a href="#BlueTangle.op_amplifier!"><code>BlueTangle.op_amplifier!</code></a></li><li><a href="#BlueTangle.product_state"><code>BlueTangle.product_state</code></a></li><li><a href="#BlueTangle.quadratic_fit"><code>BlueTangle.quadratic_fit</code></a></li><li><a href="#BlueTangle.random_clifford"><code>BlueTangle.random_clifford</code></a></li><li><a href="#BlueTangle.random_ops"><code>BlueTangle.random_ops</code></a></li><li><a href="#BlueTangle.sample"><code>BlueTangle.sample</code></a></li><li><a href="#BlueTangle.shadow"><code>BlueTangle.shadow</code></a></li><li><a href="#BlueTangle.string_to_matrix"><code>BlueTangle.string_to_matrix</code></a></li><li><a href="#BlueTangle.to_MPS"><code>BlueTangle.to_MPS</code></a></li><li><a href="#BlueTangle.to_rho"><code>BlueTangle.to_rho</code></a></li><li><a href="#BlueTangle.to_state"><code>BlueTangle.to_state</code></a></li><li><a href="#BlueTangle.variational_apply"><code>BlueTangle.variational_apply</code></a></li><li><a href="#BlueTangle.zero_state"><code>BlueTangle.zero_state</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../advanced/">« Advanced Examples</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Thursday 13 June 2024 22:21">Thursday 13 June 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
